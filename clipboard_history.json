[
  {
    "text": "Downloads\r\n",
    "timestamp": "2026-02-04 02:37:35",
    "length": 11
  },
  {
    "text": "send me that text file from today",
    "timestamp": "2026-02-04 02:33:50",
    "length": 33
  },
  {
    "text": "import logging\r\nimport asyncio\r\nimport os\r\nfrom dotenv import load_dotenv\r\nfrom telegram import Update, constants, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup\r\nfrom telegram.ext import ApplicationBuilder, ContextTypes, MessageHandler, CommandHandler, CallbackQueryHandler, filters\r\nfrom brain import process_command\r\nfrom muscles import execute_command, capture_webcam\r\nimport memory\r\nimport activity_monitor  # Needed to format the output text\r\nimport clipboard_monitor  # For clipboard history\r\nimport file_tracker  # <--- NEW IMPORT: THIS STARTS THE FILE TRACKER AUTOMATICALLY\r\n\r\nload_dotenv()\r\nTOKEN = os.getenv(\"TELEGRAM_TOKEN\")\r\n\r\nif not TOKEN:\r\n    print(\"âŒ Error: TELEGRAM_TOKEN not found in .env file.\")\r\n    exit()\r\n\r\nALLOWED_USERS = [] \r\n\r\nCAMERA_ACTIVE = False\r\n\r\n# FIXED: Changed level to WARNING to stop the console spam\r\nlogging.basicConfig(\r\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\r\n    level=logging.WARNING\r\n)\r\n\r\ndef get_main_keyboard():\r\n    # Combined keyboard: Includes old buttons + new \"/copied_texts\"\r\n    keyboard = [\r\n        [KeyboardButton(\"/screenshot\"), KeyboardButton(\"/sleep\")],\r\n        [KeyboardButton(\"/camera_off\"), KeyboardButton(\"/camera_on\")],\r\n        [KeyboardButton(\"/batterypercentage\"), KeyboardButton(\"/systemhealth\")],\r\n        [KeyboardButton(\"/location\"), KeyboardButton(\"/recordaudio\")],\r\n        [KeyboardButton(\"/clear_bin\"), KeyboardButton(\"/storage\")], \r\n        [KeyboardButton(\"/activities\"), KeyboardButton(\"/copied_texts\")] # <--- ADDED NEW BUTTON\r\n    ]\r\n    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)\r\n\r\nasync def safe_send_action(bot, chat_id, action):\r\n    \"\"\"Safely send chat action (typing/uploading) without crashing on timeout\"\"\"\r\n    try:\r\n        await bot.send_chat_action(chat_id=chat_id, action=action)\r\n    except Exception as e:\r\n        print(f\"âš ï¸ Network Warning: Could not send chat action: {e}\")\r\n\r\nasync def handle_clipboard_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    \"\"\"Handle inline button callbacks for clipboard items\"\"\"\r\n    query = update.callback_query\r\n    await query.answer()\r\n    \r\n    # Extract the clipboard index from callback data (format: \"copy_0\", \"copy_1\", etc.)\r\n    try:\r\n        _, index = query.data.split(\"_\")\r\n        index = int(index)\r\n        \r\n        # Get the clipboard item from the monitor\r\n        item = clipboard_monitor.get_clipboard_item(index)\r\n        \r\n        if item:\r\n            # Copy to user's clipboard by sending as code block (user can tap to copy)\r\n            text = item['text']\r\n            timestamp = item['timestamp']\r\n            \r\n            # Send the text with formatting\r\n            await query.message.reply_text(\r\n                f\"ğŸ“‹ **Copied Text #{index + 1}**\\n\"\r\n                f\"ğŸ• {timestamp}\\n\\n\"\r\n                f\"```\\n{text}\\n```\\n\\n\"\r\n                f\"âœ… _Tap the code block above to copy to your clipboard_\",\r\n                parse_mode='Markdown',\r\n                reply_markup=get_main_keyboard()\r\n            )\r\n        else:\r\n            await query.message.reply_text(\"âŒ Clipboard item not found.\", reply_markup=get_main_keyboard())\r\n            \r\n    except Exception as e:\r\n        print(f\"Error handling clipboard callback: {e}\")\r\n        await query.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nasync def camera_monitor_loop(bot, chat_id):\r\n    global CAMERA_ACTIVE\r\n    try:\r\n        await bot.send_message(chat_id, \"ğŸ”´ Live Feed Started...\")\r\n    except: pass\r\n    \r\n    while CAMERA_ACTIVE:\r\n        photo_path = capture_webcam()\r\n        if photo_path and os.path.exists(photo_path):\r\n            try:\r\n                await bot.send_photo(chat_id, photo=open(photo_path, 'rb'))\r\n            except Exception:\r\n                pass # Ignore network errors during stream\r\n        await asyncio.sleep(3) \r\n    \r\n    try:\r\n        await bot.send_message(chat_id, \"â¹ï¸ Camera Feed Stopped.\")\r\n    except: pass\r\n\r\n\r\nasync def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    user = update.effective_user.first_name\r\n    await update.message.reply_text(\r\n        f\"âš¡ **Pikachu Online!**\\nHello {user}. Use the buttons below.\",\r\n        reply_markup=get_main_keyboard()\r\n    )\r\n\r\nasync def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    global CAMERA_ACTIVE\r\n    user_text = update.message.text\r\n    sender = update.message.from_user.username\r\n    chat_id = update.effective_chat.id\r\n    lower_text = user_text.lower()\r\n    \r\n    print(f\"\\nğŸ“© Message from @{sender}: {user_text}\")\r\n\r\n    # 1. Safe \"Typing\" Indicator (Won't crash if internet lags)\r\n    await safe_send_action(context.bot, chat_id, constants.ChatAction.TYPING)\r\n\r\n    # Pre-process common commands\r\n    command_json = None\r\n    \r\n    if \"/battery\" in lower_text or \"battery\" in lower_text:\r\n        command_json = {\"action\": \"check_battery\"}\r\n    elif \"/systemhealth\" in lower_text or \"system health\" in lower_text:\r\n        command_json = {\"action\": \"check_health\"}\r\n    elif \"/screenshot\" in lower_text or \"screenshot\" in lower_text:\r\n        command_json = {\"action\": \"take_screenshot\"}\r\n    elif \"/sleep\" in lower_text:\r\n        command_json = {\"action\": \"system_sleep\"}\r\n    elif \"/camera_on\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"on\"}\r\n    elif \"/camera_off\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"off\"}\r\n    elif \"/recordaudio\" in lower_text or \"record audio\" in lower_text:\r\n        command_json = {\"action\": \"record_audio\", \"duration\": 10}\r\n    elif \"/location\" in lower_text or any(x in lower_text for x in [\"my location\", \"where am i\", \"laptop location\", \"where is my laptop\", \"find location\"]):\r\n        command_json = {\"action\": \"get_location\"}\r\n    # --- EXISTING BUTTON TRIGGERS ---\r\n    elif \"/clear_bin\" in lower_text or \"clear bin\" in lower_text:\r\n        command_json = {\"action\": \"clear_recycle_bin\"}\r\n    elif \"/storage\" in lower_text or \"check storage\" in lower_text:\r\n        command_json = {\"action\": \"check_storage\"}\r\n    elif \"/activities\" in lower_text or \"activities\" in lower_text:\r\n        command_json = {\"action\": \"get_activities\"}\r\n    # --- NEW CLIPBOARD TRIGGER ---\r\n    elif \"/copied_texts\" in lower_text or any(x in lower_text for x in [\"copied texts\", \"clipboard history\", \"what did i copy\", \"show copied\"]):\r\n        command_json = {\"action\": \"get_clipboard_history\"}\r\n\r\n    # Show processing message (with error handling)\r\n    status_msg = None\r\n    try:\r\n        status_msg = await update.message.reply_text(\"âš¡ Thinking...\", reply_markup=get_main_keyboard())\r\n    except Exception:\r\n        pass # If we can't send \"Thinking\", just continue\r\n\r\n    if not command_json:\r\n        loop = asyncio.get_running_loop()\r\n        try:\r\n            # Use AI to process command\r\n            command_json = await loop.run_in_executor(None, process_command, user_text)\r\n        except Exception as e:\r\n            # If AI fails, send error\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"âŒ Brain Error: {e}\", reply_markup=get_main_keyboard())\r\n            return\r\n\r\n\r\n    if command_json:\r\n        action = command_json.get('action')\r\n        \r\n        # --- ACTIVITIES HANDLER (Supports splitting messages) ---\r\n        if action == \"get_activities\":\r\n            if status_msg: await status_msg.delete()\r\n            # 1. Get raw data from muscles (which calls activity_monitor)\r\n            raw_data = execute_command(command_json)\r\n            \r\n            if raw_data:\r\n                # 2. Format the data using the helper function in activity_monitor\r\n                formatted_message = activity_monitor.format_activities_text(raw_data)\r\n                \r\n                # 3. Send the formatted text - handle both single message and multiple messages\r\n                try:\r\n                    if isinstance(formatted_message, list):\r\n                        # Multiple messages - send each one\r\n                        for i, msg in enumerate(formatted_message):\r\n                            await update.message.reply_text(\r\n                                msg, \r\n                                parse_mode='Markdown', \r\n                                reply_markup=get_main_keyboard() if i == len(formatted_message) - 1 else None\r\n                            )\r\n                            # Small delay between messages to avoid rate limiting\r\n                            if i < len(formatted_message) - 1:\r\n                                await asyncio.sleep(0.5)\r\n                    else:\r\n                        # Single message\r\n                        await update.message.reply_text(formatted_message, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n                except Exception as e:\r\n                    await update.message.reply_text(f\"âŒ Error displaying activities: {e}\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Could not fetch activities.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- NEW: CLIPBOARD HISTORY HANDLER ---\r\n        elif action == \"get_clipboard_history\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Get clipboard history from muscles -> clipboard_monitor\r\n            clipboard_items = execute_command(command_json)\r\n            \r\n            if clipboard_items and len(clipboard_items) > 0:\r\n                # Create inline keyboard with copy buttons for each item\r\n                keyboard = []\r\n                \r\n                # Show up to 20 items\r\n                for i, item in enumerate(clipboard_items[:20]):\r\n                    text = item['text']\r\n                    # Truncate text for button label\r\n                    if len(text) > 50:\r\n                        button_text = text[:47] + \"...\"\r\n                    else:\r\n                        button_text = text\r\n                    \r\n                    # Replace newlines for button display\r\n                    button_text = button_text.replace('\\n', ' ').replace('\\r', '')\r\n                    \r\n                    # Create button with callback data\r\n                    keyboard.append([InlineKeyboardButton(\r\n                        f\"{i+1}. {button_text}\",\r\n                        callback_data=f\"copy_{i}\"\r\n                    )])\r\n                \r\n                reply_markup = InlineKeyboardMarkup(keyboard)\r\n                \r\n                # Send message with buttons\r\n                await update.message.reply_text(\r\n                    f\"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    f\"Found {len(clipboard_items)} copied items.\\n\"\r\n                    f\"Tap any item below to view and copy it:\\n\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=reply_markup\r\n                )\r\n            else:\r\n                await update.message.reply_text(\r\n                    \"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    \"âŒ No copied texts found yet.\\n\"\r\n                    \"Copy some text on your desktop and try again!\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n\r\n        # --- LOCATION TRACKING ---\r\n        elif action == \"get_location\":\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ” Checking multiple location sources...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Get location data\r\n            location_data = execute_command(command_json)\r\n            \r\n            if location_data:\r\n                # Format location message\r\n                location_text = f\"\"\"ğŸŒ **Laptop Location**\r\n\r\nğŸŒ† **Location:** {location_data['city']}, {location_data['region']}\r\nğŸ³ï¸ **Country:** {location_data['country']} ({location_data['country_code']})\r\nğŸ“® **Postal Code:** {location_data['postal']}\r\nğŸŒ **IP Address:** {location_data['ip']}\r\nğŸ“¡ **ISP:** {location_data['org']}\r\nğŸ• **Timezone:** {location_data['timezone']}\r\n\r\nğŸ“Œ **Coordinates:**\r\nLatitude: {location_data['latitude']}\r\nLongitude: {location_data['longitude']}\r\n\r\nğŸ” **Data Source:** {location_data['source']}\r\n\r\nğŸ—ºï¸ [**Open in Google Maps**]({location_data['maps_url']})\r\n\"\"\"\r\n                \r\n                # Add comparison if multiple sources were checked\r\n                if location_data.get('comparison'):\r\n                    location_text += f\"\\n\\nâš ï¸ **Location Comparison:**\\n{location_data['comparison']}\\n\\n_Note: IP-based location may be 50-200km from your actual position. This shows your ISP's server location._\"\r\n                \r\n                await loader.delete()\r\n                \r\n                # Send location as text\r\n                await update.message.reply_text(\r\n                    location_text,\r\n                    parse_mode='Markdown',\r\n                    disable_web_page_preview=False,\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n                \r\n                # Send location on map (Telegram native location)\r\n                try:\r\n                    await update.message.reply_location(\r\n                        latitude=location_data['latitude'],\r\n                        longitude=location_data['longitude'],\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                except Exception as e:\r\n                    print(f\"Could not send map location: {e}\")\r\n                    \r\n            else:\r\n                await loader.edit_text(\"âŒ Failed to get location. Check internet connection.\", reply_markup=get_main_keyboard())\r\n        \r\n        # --- BATTERY CHECK ---\r\n        elif action == \"check_battery\":\r\n            status = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ”‹ {status}\", reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"check_health\":\r\n            report = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(report, reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"take_screenshot\":\r\n            # Screenshot\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ“¸ Capture...\", reply_markup=get_main_keyboard())\r\n            path = execute_command(command_json)\r\n            if path:\r\n                try:\r\n                    await update.message.reply_photo(photo=open(path, 'rb'))\r\n                    await loader.delete()\r\n                except Exception as e:\r\n                    await loader.edit_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                await loader.edit_text(\"âŒ Screenshot failed.\")\r\n                \r\n        elif action == \"system_sleep\":\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(\"ğŸ’¤ Goodnight.\", reply_markup=get_main_keyboard())\r\n            execute_command(command_json)\r\n\r\n        elif action == \"camera_stream\":\r\n            val = command_json.get(\"value\")\r\n            if status_msg: await status_msg.delete()\r\n            if val == \"on\":\r\n                if not CAMERA_ACTIVE:\r\n                    CAMERA_ACTIVE = True\r\n                    asyncio.create_task(camera_monitor_loop(context.bot, chat_id))\r\n            else:\r\n                CAMERA_ACTIVE = False\r\n                await update.message.reply_text(\"ğŸ›‘ Stopping Camera...\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"record_audio\":\r\n            if status_msg: await status_msg.delete()\r\n            duration = command_json.get(\"duration\", 10)\r\n            loader = await update.message.reply_text(f\"ğŸ¤ Recording audio for {duration} seconds...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute audio recording in executor to avoid blocking\r\n            loop = asyncio.get_running_loop()\r\n            audio_path = await loop.run_in_executor(None, execute_command, command_json)\r\n            \r\n            if audio_path and os.path.exists(audio_path):\r\n                try:\r\n                    await loader.delete()\r\n                except:\r\n                    pass  # Ignore if message already deleted\r\n                \r\n                # Send the audio file\r\n                try:\r\n                    await update.message.reply_audio(audio=open(audio_path, 'rb'), caption=\"ğŸµ Recorded Audio (10 seconds)\")\r\n                except Exception as e:\r\n                     await update.message.reply_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                try:\r\n                    await loader.edit_text(\"âŒ Audio recording failed.\")\r\n                except:\r\n                    await update.message.reply_text(\"âŒ Audio recording failed.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"general_chat\":\r\n            response = command_json.get('response', \"...\")\r\n            # AI chat response\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ’¬ {response}\", reply_markup=get_main_keyboard())\r\n\r\n        # --- RECYCLE BIN & STORAGE HANDLERS ---\r\n        elif action == \"clear_recycle_bin\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ—‘ï¸ {result}\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"check_storage\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(result, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n        # --------------------------------------\r\n\r\n        # --- File / App Handling ---\r\n        elif action == \"list_files\":\r\n            if status_msg: await status_msg.delete()\r\n            raw_path = command_json.get('path')\r\n            if \"desktop\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\r\n            elif \"downloads\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\r\n            \r\n            if os.path.exists(raw_path):\r\n                try:\r\n                    files = os.listdir(raw_path)[:20]\r\n                    text = \"\\n\".join([f\"ğŸ“¹ {f}\" for f in files])\r\n                    await update.message.reply_text(f\"ğŸ“‚ **Files:**\\n{text}\", reply_markup=get_main_keyboard())\r\n                except: \r\n                    await update.message.reply_text(\"âŒ Failed to read folder.\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Folder not found.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"send_file\":\r\n             if status_msg: await status_msg.delete()\r\n             raw_path = command_json.get('path')\r\n             if os.path.exists(raw_path):\r\n                 try:\r\n                     await update.message.reply_text(\"ğŸ“¤ Uploading...\", reply_markup=get_main_keyboard())\r\n                     await update.message.reply_document(open(raw_path, 'rb'))\r\n                 except Exception as e:\r\n                     print(f\"Upload Error: {e}\")\r\n                     await update.message.reply_text(\"âŒ Error: File upload timed out or failed.\", reply_markup=get_main_keyboard())\r\n             else:\r\n                 await update.message.reply_text(\"âŒ File not found.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- FIND FILE HANDLER (Context-Aware File Finder) ---\r\n        elif action == \"find_file\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Show searching message\r\n            search_msg = await update.message.reply_text(\"ğŸ” Searching for file...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute file search in background thread\r\n            loop = asyncio.get_running_loop()\r\n            try:\r\n                search_result = await loop.run_in_executor(None, execute_command, command_json)\r\n                \r\n                if not search_result:\r\n                    await search_msg.edit_text(\"âŒ File search failed.\", reply_markup=get_main_keyboard())\r\n                    return\r\n                \r\n                status = search_result.get(\"status\")\r\n                \r\n                if status == \"found\":\r\n                    # File found!\r\n                    file_path = search_result.get(\"file_path\")\r\n                    file_name = search_result.get(\"file_name\")\r\n                    file_size_mb = search_result.get(\"file_size_mb\", 0)\r\n                    confidence = search_result.get(\"confidence\", 0)\r\n                    \r\n                    # --- NEW METADATA DISPLAY ---\r\n                    app_used = search_result.get(\"app_used\", \"Unknown App\")\r\n                    timestamp = search_result.get(\"timestamp\", \"Unknown Time\")\r\n                    duration = search_result.get(\"duration\", 0)\r\n                    \r\n                    # Format duration string\r\n                    if duration < 60:\r\n                        duration_str = f\"{duration}s\"\r\n                    else:\r\n                        m, s = divmod(duration, 60)\r\n                        duration_str = f\"{m}m {s}s\"\r\n                    \r\n                    # Create Detailed Caption\r\n                    caption_text = (\r\n                        f\"âœ… **Found:** {file_name}\\n\"\r\n                        f\"ğŸ“± **App:** {app_used}\\n\"\r\n                        f\"ğŸ“… **Time:** {timestamp}\\n\"\r\n                        f\"â±ï¸ **Duration:** {duration_str}\\n\"\r\n                        f\"ğŸ¯ **Confidence:** {confidence}%\"\r\n                    )\r\n                    # -----------------------------\r\n                    \r\n                    await search_msg.delete()\r\n                    \r\n                    # Send file size warning if large\r\n                    size_warning = \"\"\r\n                    if file_size_mb > 20:\r\n                        size_warning = f\"\\n\\nâš ï¸ _Large file: {file_size_mb:.1f} MB_\"\r\n                    \r\n                    # Send loading message\r\n                    upload_msg = await update.message.reply_text(\r\n                        f\"ğŸ“¤ Uploading: **{file_name}**{size_warning}\",\r\n                        parse_mode='Markdown',\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                    \r\n                    # Upload the file with new caption\r\n                    try:\r\n                        await update.message.reply_document(\r\n                            document=open(file_path, 'rb'),\r\n                            caption=caption_text,\r\n                            parse_mode='Markdown',\r\n                            reply_markup=get_main_keyboard()\r\n                        )\r\n                        await upload_msg.delete()\r\n                        \r\n                        # Update memory with successful file type preference\r\n                        import memory\r\n                        file_ext = os.path.splitext(file_name)[1].replace('.', '').lower()\r\n                        memory.track_file_preference(file_ext)\r\n                        \r\n                    except Exception as e:\r\n                        print(f\"Upload Error: {e}\")\r\n                        await upload_msg.edit_text(f\"âŒ Upload failed: {e}\", reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"not_found\":\r\n                    # No files found\r\n                    message = search_result.get(\"message\", \"No files found.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"file_deleted\":\r\n                    # File was found but doesn't exist anymore\r\n                    message = search_result.get(\"message\", \"File no longer exists.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"too_large\":\r\n                    # File too large for Telegram\r\n                    message = search_result.get(\"message\", \"File too large.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                else:\r\n                    # Unknown status or error\r\n                    message = search_result.get(\"message\", \"Search completed with unknown status.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                    \r\n            except Exception as e:\r\n                print(f\"Find file error: {e}\")\r\n                await search_msg.edit_text(f\"âŒ Search error: {e}\", reply_markup=get_main_keyboard())\r\n        # ---------------------------------------------------------\r\n\r\n        else:\r\n            # Generic action execution\r\n            try:\r\n                execute_command(command_json)\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âœ… Action Complete: {action}\", reply_markup=get_main_keyboard())\r\n            except Exception as e:\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"ğŸš€ TELEGRAM BOT STARTED...\")\r\n    try:\r\n        # Increase connection timeout to handle slow uploads better\r\n        application = ApplicationBuilder().token(TOKEN).read_timeout(60).write_timeout(60).build()\r\n        \r\n        # Add handlers\r\n        application.add_handler(CommandHandler(\"start\", start_command))\r\n        application.add_handler(CallbackQueryHandler(handle_clipboard_callback)) # NEW: Clipboard handler\r\n        application.add_handler(MessageHandler(filters.TEXT | filters.COMMAND, handle_message))\r\n        \r\n        application.run_polling()\r\n    except Exception as e:\r\n        print(f\"âŒ Critical Error: {e}\")",
    "timestamp": "2026-02-04 02:28:20",
    "length": 26043
  },
  {
    "text": "ebe tu telegram re khali lekhibu send me the pdf i was stu",
    "timestamp": "2026-02-04 02:18:47",
    "length": 58
  },
  {
    "text": "i know its a long line of codes, but please please dont skip anything, please update the code properly that it will work, and please im begging you to dont skip/remove anything those already existsğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­",
    "timestamp": "2026-02-04 02:14:58",
    "length": 241
  },
  {
    "text": "import logging\r\nimport asyncio\r\nimport os\r\nfrom dotenv import load_dotenv\r\nfrom telegram import Update, constants, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup\r\nfrom telegram.ext import ApplicationBuilder, ContextTypes, MessageHandler, CommandHandler, CallbackQueryHandler, filters\r\nfrom brain import process_command\r\nfrom muscles import execute_command, capture_webcam\r\nimport memory\r\nimport activity_monitor  # Needed to format the output text\r\nimport clipboard_monitor  # For clipboard history\r\nimport file_tracker  # <--- NEW IMPORT: THIS STARTS THE FILE TRACKER AUTOMATICALLY\r\n\r\nload_dotenv()\r\nTOKEN = os.getenv(\"TELEGRAM_TOKEN\")\r\n\r\nif not TOKEN:\r\n    print(\"âŒ Error: TELEGRAM_TOKEN not found in .env file.\")\r\n    exit()\r\n\r\nALLOWED_USERS = [] \r\n\r\nCAMERA_ACTIVE = False\r\n\r\n# FIXED: Changed level to WARNING to stop the console spam\r\nlogging.basicConfig(\r\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\r\n    level=logging.WARNING\r\n)\r\n\r\ndef get_main_keyboard():\r\n    # Combined keyboard: Includes old buttons + new \"/copied_texts\"\r\n    keyboard = [\r\n        [KeyboardButton(\"/screenshot\"), KeyboardButton(\"/sleep\")],\r\n        [KeyboardButton(\"/camera_off\"), KeyboardButton(\"/camera_on\")],\r\n        [KeyboardButton(\"/batterypercentage\"), KeyboardButton(\"/systemhealth\")],\r\n        [KeyboardButton(\"/location\"), KeyboardButton(\"/recordaudio\")],\r\n        [KeyboardButton(\"/clear_bin\"), KeyboardButton(\"/storage\")], \r\n        [KeyboardButton(\"/activities\"), KeyboardButton(\"/copied_texts\")] # <--- ADDED NEW BUTTON\r\n    ]\r\n    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)\r\n\r\nasync def safe_send_action(bot, chat_id, action):\r\n    \"\"\"Safely send chat action (typing/uploading) without crashing on timeout\"\"\"\r\n    try:\r\n        await bot.send_chat_action(chat_id=chat_id, action=action)\r\n    except Exception as e:\r\n        print(f\"âš ï¸ Network Warning: Could not send chat action: {e}\")\r\n\r\nasync def handle_clipboard_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    \"\"\"Handle inline button callbacks for clipboard items\"\"\"\r\n    query = update.callback_query\r\n    await query.answer()\r\n    \r\n    # Extract the clipboard index from callback data (format: \"copy_0\", \"copy_1\", etc.)\r\n    try:\r\n        _, index = query.data.split(\"_\")\r\n        index = int(index)\r\n        \r\n        # Get the clipboard item from the monitor\r\n        item = clipboard_monitor.get_clipboard_item(index)\r\n        \r\n        if item:\r\n            # Copy to user's clipboard by sending as code block (user can tap to copy)\r\n            text = item['text']\r\n            timestamp = item['timestamp']\r\n            \r\n            # Send the text with formatting\r\n            await query.message.reply_text(\r\n                f\"ğŸ“‹ **Copied Text #{index + 1}**\\n\"\r\n                f\"ğŸ• {timestamp}\\n\\n\"\r\n                f\"```\\n{text}\\n```\\n\\n\"\r\n                f\"âœ… _Tap the code block above to copy to your clipboard_\",\r\n                parse_mode='Markdown',\r\n                reply_markup=get_main_keyboard()\r\n            )\r\n        else:\r\n            await query.message.reply_text(\"âŒ Clipboard item not found.\", reply_markup=get_main_keyboard())\r\n            \r\n    except Exception as e:\r\n        print(f\"Error handling clipboard callback: {e}\")\r\n        await query.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nasync def camera_monitor_loop(bot, chat_id):\r\n    global CAMERA_ACTIVE\r\n    try:\r\n        await bot.send_message(chat_id, \"ğŸ”´ Live Feed Started...\")\r\n    except: pass\r\n    \r\n    while CAMERA_ACTIVE:\r\n        photo_path = capture_webcam()\r\n        if photo_path and os.path.exists(photo_path):\r\n            try:\r\n                await bot.send_photo(chat_id, photo=open(photo_path, 'rb'))\r\n            except Exception:\r\n                pass # Ignore network errors during stream\r\n        await asyncio.sleep(3) \r\n    \r\n    try:\r\n        await bot.send_message(chat_id, \"â¹ï¸ Camera Feed Stopped.\")\r\n    except: pass\r\n\r\n\r\nasync def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    user = update.effective_user.first_name\r\n    await update.message.reply_text(\r\n        f\"âš¡ **Pikachu Online!**\\nHello {user}. Use the buttons below.\",\r\n        reply_markup=get_main_keyboard()\r\n    )\r\n\r\nasync def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    global CAMERA_ACTIVE\r\n    user_text = update.message.text\r\n    sender = update.message.from_user.username\r\n    chat_id = update.effective_chat.id\r\n    lower_text = user_text.lower()\r\n    \r\n    print(f\"\\nğŸ“© Message from @{sender}: {user_text}\")\r\n\r\n    # 1. Safe \"Typing\" Indicator (Won't crash if internet lags)\r\n    await safe_send_action(context.bot, chat_id, constants.ChatAction.TYPING)\r\n\r\n    # Pre-process common commands\r\n    command_json = None\r\n    \r\n    if \"/battery\" in lower_text or \"battery\" in lower_text:\r\n        command_json = {\"action\": \"check_battery\"}\r\n    elif \"/systemhealth\" in lower_text or \"system health\" in lower_text:\r\n        command_json = {\"action\": \"check_health\"}\r\n    elif \"/screenshot\" in lower_text or \"screenshot\" in lower_text:\r\n        command_json = {\"action\": \"take_screenshot\"}\r\n    elif \"/sleep\" in lower_text:\r\n        command_json = {\"action\": \"system_sleep\"}\r\n    elif \"/camera_on\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"on\"}\r\n    elif \"/camera_off\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"off\"}\r\n    elif \"/recordaudio\" in lower_text or \"record audio\" in lower_text:\r\n        command_json = {\"action\": \"record_audio\", \"duration\": 10}\r\n    elif \"/location\" in lower_text or any(x in lower_text for x in [\"my location\", \"where am i\", \"laptop location\", \"where is my laptop\", \"find location\"]):\r\n        command_json = {\"action\": \"get_location\"}\r\n    # --- EXISTING BUTTON TRIGGERS ---\r\n    elif \"/clear_bin\" in lower_text or \"clear bin\" in lower_text:\r\n        command_json = {\"action\": \"clear_recycle_bin\"}\r\n    elif \"/storage\" in lower_text or \"check storage\" in lower_text:\r\n        command_json = {\"action\": \"check_storage\"}\r\n    elif \"/activities\" in lower_text or \"activities\" in lower_text:\r\n        command_json = {\"action\": \"get_activities\"}\r\n    # --- NEW CLIPBOARD TRIGGER ---\r\n    elif \"/copied_texts\" in lower_text or any(x in lower_text for x in [\"copied texts\", \"clipboard history\", \"what did i copy\", \"show copied\"]):\r\n        command_json = {\"action\": \"get_clipboard_history\"}\r\n\r\n    # Show processing message (with error handling)\r\n    status_msg = None\r\n    try:\r\n        status_msg = await update.message.reply_text(\"âš¡ Thinking...\", reply_markup=get_main_keyboard())\r\n    except Exception:\r\n        pass # If we can't send \"Thinking\", just continue\r\n\r\n    if not command_json:\r\n        loop = asyncio.get_running_loop()\r\n        try:\r\n            # Use AI to process command\r\n            command_json = await loop.run_in_executor(None, process_command, user_text)\r\n        except Exception as e:\r\n            # If AI fails, send error\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"âŒ Brain Error: {e}\", reply_markup=get_main_keyboard())\r\n            return\r\n\r\n\r\n    if command_json:\r\n        action = command_json.get('action')\r\n        \r\n        # --- ACTIVITIES HANDLER (Supports splitting messages) ---\r\n        if action == \"get_activities\":\r\n            if status_msg: await status_msg.delete()\r\n            # 1. Get raw data from muscles (which calls activity_monitor)\r\n            raw_data = execute_command(command_json)\r\n            \r\n            if raw_data:\r\n                # 2. Format the data using the helper function in activity_monitor\r\n                formatted_message = activity_monitor.format_activities_text(raw_data)\r\n                \r\n                # 3. Send the formatted text - handle both single message and multiple messages\r\n                try:\r\n                    if isinstance(formatted_message, list):\r\n                        # Multiple messages - send each one\r\n                        for i, msg in enumerate(formatted_message):\r\n                            await update.message.reply_text(\r\n                                msg, \r\n                                parse_mode='Markdown', \r\n                                reply_markup=get_main_keyboard() if i == len(formatted_message) - 1 else None\r\n                            )\r\n                            # Small delay between messages to avoid rate limiting\r\n                            if i < len(formatted_message) - 1:\r\n                                await asyncio.sleep(0.5)\r\n                    else:\r\n                        # Single message\r\n                        await update.message.reply_text(formatted_message, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n                except Exception as e:\r\n                    await update.message.reply_text(f\"âŒ Error displaying activities: {e}\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Could not fetch activities.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- NEW: CLIPBOARD HISTORY HANDLER ---\r\n        elif action == \"get_clipboard_history\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Get clipboard history from muscles -> clipboard_monitor\r\n            clipboard_items = execute_command(command_json)\r\n            \r\n            if clipboard_items and len(clipboard_items) > 0:\r\n                # Create inline keyboard with copy buttons for each item\r\n                keyboard = []\r\n                \r\n                # Show up to 20 items\r\n                for i, item in enumerate(clipboard_items[:20]):\r\n                    text = item['text']\r\n                    # Truncate text for button label\r\n                    if len(text) > 50:\r\n                        button_text = text[:47] + \"...\"\r\n                    else:\r\n                        button_text = text\r\n                    \r\n                    # Replace newlines for button display\r\n                    button_text = button_text.replace('\\n', ' ').replace('\\r', '')\r\n                    \r\n                    # Create button with callback data\r\n                    keyboard.append([InlineKeyboardButton(\r\n                        f\"{i+1}. {button_text}\",\r\n                        callback_data=f\"copy_{i}\"\r\n                    )])\r\n                \r\n                reply_markup = InlineKeyboardMarkup(keyboard)\r\n                \r\n                # Send message with buttons\r\n                await update.message.reply_text(\r\n                    f\"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    f\"Found {len(clipboard_items)} copied items.\\n\"\r\n                    f\"Tap any item below to view and copy it:\\n\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=reply_markup\r\n                )\r\n            else:\r\n                await update.message.reply_text(\r\n                    \"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    \"âŒ No copied texts found yet.\\n\"\r\n                    \"Copy some text on your desktop and try again!\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n\r\n        # --- LOCATION TRACKING ---\r\n        elif action == \"get_location\":\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ” Checking multiple location sources...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Get location data\r\n            location_data = execute_command(command_json)\r\n            \r\n            if location_data:\r\n                # Format location message\r\n                location_text = f\"\"\"ğŸŒ **Laptop Location**\r\n\r\nğŸŒ† **Location:** {location_data['city']}, {location_data['region']}\r\nğŸ³ï¸ **Country:** {location_data['country']} ({location_data['country_code']})\r\nğŸ“® **Postal Code:** {location_data['postal']}\r\nğŸŒ **IP Address:** {location_data['ip']}\r\nğŸ“¡ **ISP:** {location_data['org']}\r\nğŸ• **Timezone:** {location_data['timezone']}\r\n\r\nğŸ“Œ **Coordinates:**\r\nLatitude: {location_data['latitude']}\r\nLongitude: {location_data['longitude']}\r\n\r\nğŸ” **Data Source:** {location_data['source']}\r\n\r\nğŸ—ºï¸ [**Open in Google Maps**]({location_data['maps_url']})\r\n\"\"\"\r\n                \r\n                # Add comparison if multiple sources were checked\r\n                if location_data.get('comparison'):\r\n                    location_text += f\"\\n\\nâš ï¸ **Location Comparison:**\\n{location_data['comparison']}\\n\\n_Note: IP-based location may be 50-200km from your actual position. This shows your ISP's server location._\"\r\n                \r\n                await loader.delete()\r\n                \r\n                # Send location as text\r\n                await update.message.reply_text(\r\n                    location_text,\r\n                    parse_mode='Markdown',\r\n                    disable_web_page_preview=False,\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n                \r\n                # Send location on map (Telegram native location)\r\n                try:\r\n                    await update.message.reply_location(\r\n                        latitude=location_data['latitude'],\r\n                        longitude=location_data['longitude'],\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                except Exception as e:\r\n                    print(f\"Could not send map location: {e}\")\r\n                    \r\n            else:\r\n                await loader.edit_text(\"âŒ Failed to get location. Check internet connection.\", reply_markup=get_main_keyboard())\r\n        \r\n        # --- BATTERY CHECK ---\r\n        elif action == \"check_battery\":\r\n            status = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ”‹ {status}\", reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"check_health\":\r\n            report = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(report, reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"take_screenshot\":\r\n            # Screenshot\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ“¸ Capture...\", reply_markup=get_main_keyboard())\r\n            path = execute_command(command_json)\r\n            if path:\r\n                try:\r\n                    await update.message.reply_photo(photo=open(path, 'rb'))\r\n                    await loader.delete()\r\n                except Exception as e:\r\n                    await loader.edit_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                await loader.edit_text(\"âŒ Screenshot failed.\")\r\n                \r\n        elif action == \"system_sleep\":\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(\"ğŸ’¤ Goodnight.\", reply_markup=get_main_keyboard())\r\n            execute_command(command_json)\r\n\r\n        elif action == \"camera_stream\":\r\n            val = command_json.get(\"value\")\r\n            if status_msg: await status_msg.delete()\r\n            if val == \"on\":\r\n                if not CAMERA_ACTIVE:\r\n                    CAMERA_ACTIVE = True\r\n                    asyncio.create_task(camera_monitor_loop(context.bot, chat_id))\r\n            else:\r\n                CAMERA_ACTIVE = False\r\n                await update.message.reply_text(\"ğŸ›‘ Stopping Camera...\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"record_audio\":\r\n            if status_msg: await status_msg.delete()\r\n            duration = command_json.get(\"duration\", 10)\r\n            loader = await update.message.reply_text(f\"ğŸ¤ Recording audio for {duration} seconds...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute audio recording in executor to avoid blocking\r\n            loop = asyncio.get_running_loop()\r\n            audio_path = await loop.run_in_executor(None, execute_command, command_json)\r\n            \r\n            if audio_path and os.path.exists(audio_path):\r\n                try:\r\n                    await loader.delete()\r\n                except:\r\n                    pass  # Ignore if message already deleted\r\n                \r\n                # Send the audio file\r\n                try:\r\n                    await update.message.reply_audio(audio=open(audio_path, 'rb'), caption=\"ğŸµ Recorded Audio (10 seconds)\")\r\n                except Exception as e:\r\n                     await update.message.reply_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                try:\r\n                    await loader.edit_text(\"âŒ Audio recording failed.\")\r\n                except:\r\n                    await update.message.reply_text(\"âŒ Audio recording failed.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"general_chat\":\r\n            response = command_json.get('response', \"...\")\r\n            # AI chat response\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ’¬ {response}\", reply_markup=get_main_keyboard())\r\n\r\n        # --- RECYCLE BIN & STORAGE HANDLERS ---\r\n        elif action == \"clear_recycle_bin\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ—‘ï¸ {result}\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"check_storage\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(result, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n        # --------------------------------------\r\n\r\n        # --- File / App Handling ---\r\n        elif action == \"list_files\":\r\n            if status_msg: await status_msg.delete()\r\n            raw_path = command_json.get('path')\r\n            if \"desktop\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\r\n            elif \"downloads\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\r\n            \r\n            if os.path.exists(raw_path):\r\n                try:\r\n                    files = os.listdir(raw_path)[:20]\r\n                    text = \"\\n\".join([f\"ğŸ“¹ {f}\" for f in files])\r\n                    await update.message.reply_text(f\"ğŸ“‚ **Files:**\\n{text}\", reply_markup=get_main_keyboard())\r\n                except: \r\n                    await update.message.reply_text(\"âŒ Failed to read folder.\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Folder not found.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"send_file\":\r\n             if status_msg: await status_msg.delete()\r\n             raw_path = command_json.get('path')\r\n             if os.path.exists(raw_path):\r\n                 try:\r\n                     await update.message.reply_text(\"ğŸ“¤ Uploading...\", reply_markup=get_main_keyboard())\r\n                     await update.message.reply_document(open(raw_path, 'rb'))\r\n                 except Exception as e:\r\n                     print(f\"Upload Error: {e}\")\r\n                     await update.message.reply_text(\"âŒ Error: File upload timed out or failed.\", reply_markup=get_main_keyboard())\r\n             else:\r\n                 await update.message.reply_text(\"âŒ File not found.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- FIND FILE HANDLER (Context-Aware File Finder) ---\r\n        elif action == \"find_file\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Show searching message\r\n            search_msg = await update.message.reply_text(\"ğŸ” Searching for file...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute file search in background thread\r\n            loop = asyncio.get_running_loop()\r\n            try:\r\n                search_result = await loop.run_in_executor(None, execute_command, command_json)\r\n                \r\n                if not search_result:\r\n                    await search_msg.edit_text(\"âŒ File search failed.\", reply_markup=get_main_keyboard())\r\n                    return\r\n                \r\n                status = search_result.get(\"status\")\r\n                \r\n                if status == \"found\":\r\n                    # File found! Send it\r\n                    file_path = search_result.get(\"file_path\")\r\n                    file_name = search_result.get(\"file_name\")\r\n                    file_size_mb = search_result.get(\"file_size_mb\", 0)\r\n                    confidence = search_result.get(\"confidence\", 0)\r\n                    \r\n                    await search_msg.delete()\r\n                    \r\n                    # Send file size warning if large\r\n                    size_warning = \"\"\r\n                    if file_size_mb > 20:\r\n                        size_warning = f\"\\n\\nâš ï¸ _Large file: {file_size_mb:.1f} MB_\"\r\n                    \r\n                    # Send the file\r\n                    upload_msg = await update.message.reply_text(\r\n                        f\"ğŸ“¤ Uploading: **{file_name}**{size_warning}\",\r\n                        parse_mode='Markdown',\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                    \r\n                    try:\r\n                        await update.message.reply_document(\r\n                            document=open(file_path, 'rb'),\r\n                            caption=f\"âœ… Found: {file_name}\\nğŸ¯ Confidence: {confidence}%\",\r\n                            reply_markup=get_main_keyboard()\r\n                        )\r\n                        await upload_msg.delete()\r\n                        \r\n                        # Update memory with successful file type preference\r\n                        import memory\r\n                        file_ext = os.path.splitext(file_name)[1].replace('.', '').lower()\r\n                        memory.track_file_preference(file_ext)\r\n                        \r\n                    except Exception as e:\r\n                        print(f\"Upload Error: {e}\")\r\n                        await upload_msg.edit_text(f\"âŒ Upload failed: {e}\", reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"not_found\":\r\n                    # No files found\r\n                    message = search_result.get(\"message\", \"No files found.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"file_deleted\":\r\n                    # File was found but doesn't exist anymore\r\n                    message = search_result.get(\"message\", \"File no longer exists.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"too_large\":\r\n                    # File too large for Telegram\r\n                    message = search_result.get(\"message\", \"File too large.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                else:\r\n                    # Unknown status or error\r\n                    message = search_result.get(\"message\", \"Search completed with unknown status.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                    \r\n            except Exception as e:\r\n                print(f\"Find file error: {e}\")\r\n                await search_msg.edit_text(f\"âŒ Search error: {e}\", reply_markup=get_main_keyboard())\r\n        # ---------------------------------------------------------\r\n\r\n        else:\r\n            # Generic action execution\r\n            try:\r\n                execute_command(command_json)\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âœ… Action Complete: {action}\", reply_markup=get_main_keyboard())\r\n            except Exception as e:\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"ğŸš€ TELEGRAM BOT STARTED...\")\r\n    try:\r\n        # Increase connection timeout to handle slow uploads better\r\n        application = ApplicationBuilder().token(TOKEN).read_timeout(60).write_timeout(60).build()\r\n        \r\n        # Add handlers\r\n        application.add_handler(CommandHandler(\"start\", start_command))\r\n        application.add_handler(CallbackQueryHandler(handle_clipboard_callback)) # NEW: Clipboard handler\r\n        application.add_handler(MessageHandler(filters.TEXT | filters.COMMAND, handle_message))\r\n        \r\n        application.run_polling()\r\n    except Exception as e:\r\n        print(f\"âŒ Critical Error: {e}\")",
    "timestamp": "2026-02-04 02:13:54",
    "length": 24919
  },
  {
    "text": "def execute_find_file(action_data):\r\n    \"\"\"\r\n    Execute file finding using the file_finder module\r\n    Returns file path if found (for Telegram sending), or error message\r\n    \"\"\"\r\n    print(\"ğŸ” Searching for file...\")\r\n    \r\n    try:\r\n        # Get the search query (brain.py now sends \"query\" instead of time_query/file_type)\r\n        query = action_data.get(\"query\")\r\n        \r\n        if not query:\r\n            # Fallback for old format (backward compatibility)\r\n            time_query = action_data.get(\"time_query\")\r\n            file_type = action_data.get(\"file_type\")\r\n            keyword = action_data.get(\"keyword\")\r\n            \r\n            if time_query:\r\n                query = time_query\r\n            else:\r\n                parts = []\r\n                if file_type:\r\n                    parts.append(file_type)\r\n                if keyword:\r\n                    parts.append(keyword)\r\n                query = \" \".join(parts) if parts else \"recent files\"\r\n        \r\n        # Search for files using the natural language query\r\n        print(f\"   Query: '{query}'\")\r\n        results = find_files_from_query(query, limit=3)\r\n        \r\n        if not results:\r\n            # No files found - return helpful message\r\n            print(\"   âŒ No matching files found\")\r\n            return {\r\n                \"status\": \"not_found\",\r\n                \"message\": \"âš ï¸ No matching files found.\\n\\nTry:\\nâ€¢ 'files opened today'\\nâ€¢ 'PDFs from yesterday'\\nâ€¢ 'recent documents'\"\r\n            }\r\n        \r\n        # Files found!\r\n        top_result = results[0]\r\n        file_path = top_result['file_path']\r\n        file_name = top_result['file_name']\r\n        confidence = top_result.get('confidence_score', 0)\r\n        \r\n        # --- NEW: Extract Metadata ---\r\n        app_used = top_result.get('app_used', 'Unknown App')\r\n        timestamp = top_result.get('timestamp', 'Unknown Time')\r\n        duration = top_result.get('duration_seconds', 0)\r\n        # -----------------------------\r\n        \r\n        print(f\"   âœ… Found: {file_name} (confidence: {confidence}%)\")\r\n        \r\n        # Check if file still exists\r\n        if not os.path.exists(file_path):\r\n            print(f\"   âš ï¸ File was moved/deleted: {file_path}\")\r\n            \r\n            # If we have multiple results, try the next one\r\n            if len(results) > 1:\r\n                for result in results[1:]:\r\n                    if os.path.exists(result['file_path']):\r\n                        file_path = result['file_path']\r\n                        file_name = result['file_name']\r\n                        \r\n                        # Update metadata for the alternate file\r\n                        app_used = result.get('app_used', 'Unknown App')\r\n                        timestamp = result.get('timestamp', 'Unknown Time')\r\n                        duration = result.get('duration_seconds', 0)\r\n                        confidence = result.get('confidence_score', 0)\r\n                        \r\n                        print(f\"   âœ… Using alternate: {file_name}\")\r\n                        break\r\n                else:\r\n                    # None of the results exist\r\n                    return {\r\n                        \"status\": \"file_deleted\",\r\n                        \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                    }\r\n            else:\r\n                return {\r\n                    \"status\": \"file_deleted\",\r\n                    \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                }\r\n        \r\n        # Check file size (Telegram limit is 50MB, warn if >20MB)\r\n        try:\r\n            file_size_mb = os.path.getsize(file_path) / (1024 * 1024)\r\n        except:\r\n            file_size_mb = 0\r\n            \r\n        if file_size_mb > 50:\r\n            return {\r\n                \"status\": \"too_large\",\r\n                \"message\": f\"âŒ File is too large to send via Telegram:\\n{file_name}\\n\\nSize: {file_size_mb:.1f} MB (Telegram limit: 50 MB)\\n\\nPath: {file_path}\"\r\n            }\r\n        \r\n        # Success - return file info for Telegram to send\r\n        return {\r\n            \"status\": \"found\",\r\n            \"file_path\": file_path,\r\n            \"file_name\": file_name,\r\n            \"file_size_mb\": file_size_mb,\r\n            \"confidence\": confidence,\r\n            \"app_used\": app_used,       # <--- Passing this to Telegram\r\n            \"timestamp\": timestamp,     # <--- Passing this to Telegram\r\n            \"duration\": duration,       # <--- Passing this to Telegram\r\n            \"results\": results          # All results for reference\r\n        }\r\n        \r\n    except Exception as e:\r\n        error_msg = f\"Error during file search: {e}\"\r\n        print(f\"   âŒ {error_msg}\")\r\n        return {\r\n            \"status\": \"error\",\r\n            \"message\": f\"âŒ Search error: {e}\"\r\n        }",
    "timestamp": "2026-02-04 02:13:17",
    "length": 4906
  },
  {
    "text": "def execute_find_file(action_data):\r\n    \"\"\"\r\n    Execute file finding using the file_finder module\r\n    Returns file path if found (for Telegram sending), or error message\r\n    \"\"\"\r\n    print(\"ğŸ” Searching for file...\")\r\n    \r\n    try:\r\n        # Get the search query (brain.py now sends \"query\" instead of time_query/file_type)\r\n        query = action_data.get(\"query\")\r\n        \r\n        if not query:\r\n            # Fallback for old format (backward compatibility)\r\n            time_query = action_data.get(\"time_query\")\r\n            file_type = action_data.get(\"file_type\")\r\n            keyword = action_data.get(\"keyword\")\r\n            \r\n            if time_query:\r\n                query = time_query\r\n            else:\r\n                parts = []\r\n                if file_type:\r\n                    parts.append(file_type)\r\n                if keyword:\r\n                    parts.append(keyword)\r\n                query = \" \".join(parts) if parts else \"recent files\"\r\n        \r\n        # Search for files using the natural language query\r\n        print(f\"   Query: '{query}'\")\r\n        results = find_files_from_query(query, limit=3)\r\n        \r\n        if not results:\r\n            # No files found - return helpful message\r\n            print(\"   âŒ No matching files found\")\r\n            return {\r\n                \"status\": \"not_found\",\r\n                \"message\": \"âš ï¸ No matching files found.\\n\\nTry:\\nâ€¢ 'files opened today'\\nâ€¢ 'PDFs from yesterday'\\nâ€¢ 'recent documents'\"\r\n            }\r\n        \r\n        # Files found!\r\n        top_result = results[0]\r\n        file_path = top_result['file_path']\r\n        file_name = top_result['file_name']\r\n        confidence = top_result.get('confidence_score', 0)\r\n        \r\n        print(f\"   âœ… Found: {file_name} (confidence: {confidence}%)\")\r\n        \r\n        # Check if file still exists\r\n        if not os.path.exists(file_path):\r\n            print(f\"   âš ï¸ File was moved/deleted: {file_path}\")\r\n            \r\n            # If we have multiple results, try the next one\r\n            if len(results) > 1:\r\n                for result in results[1:]:\r\n                    if os.path.exists(result['file_path']):\r\n                        file_path = result['file_path']\r\n                        file_name = result['file_name']\r\n                        print(f\"   âœ… Using alternate: {file_name}\")\r\n                        break\r\n                else:\r\n                    # None of the results exist\r\n                    return {\r\n                        \"status\": \"file_deleted\",\r\n                        \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                    }\r\n            else:\r\n                return {\r\n                    \"status\": \"file_deleted\",\r\n                    \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                }\r\n        \r\n        # Check file size (Telegram limit is 50MB, warn if >20MB)\r\n        file_size_mb = os.path.getsize(file_path) / (1024 * 1024)\r\n        \r\n        if file_size_mb > 50:\r\n            return {\r\n                \"status\": \"too_large\",\r\n                \"message\": f\"âŒ File is too large to send via Telegram:\\n{file_name}\\n\\nSize: {file_size_mb:.1f} MB (Telegram limit: 50 MB)\\n\\nPath: {file_path}\"\r\n            }\r\n        \r\n        # Success - return file info for Telegram to send\r\n        return {\r\n            \"status\": \"found\",\r\n            \"file_path\": file_path,\r\n            \"file_name\": file_name,\r\n            \"file_size_mb\": file_size_mb,\r\n            \"confidence\": confidence,\r\n            \"results\": results  # All results for reference\r\n        }\r\n        \r\n    except Exception as e:\r\n        error_msg = f\"Error during file search: {e}\"\r\n        print(f\"   âŒ {error_msg}\")\r\n        return {\r\n            \"status\": \"error\",\r\n            \"message\": f\"âŒ Search error: {e}\"\r\n        }\r\n",
    "timestamp": "2026-02-04 02:12:08",
    "length": 3924
  },
  {
    "text": "def execute_find_file(action_data):\r\n    \"\"\"\r\n    Execute file finding using the file_finder module\r\n    Returns file path if found (for Telegram sending), or error message\r\n    \"\"\"\r\n    print(\"ğŸ” Searching for file...\")\r\n    \r\n    try:\r\n        # Get the search query\r\n        query = action_data.get(\"query\")\r\n        \r\n        if not query:\r\n            # Fallback for old format\r\n            time_query = action_data.get(\"time_query\")\r\n            file_type = action_data.get(\"file_type\")\r\n            keyword = action_data.get(\"keyword\")\r\n            \r\n            if time_query:\r\n                query = time_query\r\n            else:\r\n                parts = []\r\n                if file_type: parts.append(file_type)\r\n                if keyword: parts.append(keyword)\r\n                query = \" \".join(parts) if parts else \"recent files\"\r\n        \r\n        # Search for files\r\n        print(f\"   Query: '{query}'\")\r\n        results = find_files_from_query(query, limit=3)\r\n        \r\n        if not results:\r\n            print(\"   âŒ No matching files found\")\r\n            return {\r\n                \"status\": \"not_found\",\r\n                \"message\": \"âš ï¸ No matching files found.\\n\\nTry:\\nâ€¢ 'files opened today'\\nâ€¢ 'PDFs from yesterday'\\nâ€¢ 'recent documents'\"\r\n            }\r\n        \r\n        # Files found! Pick the best one (Index 0)\r\n        top_result = results[0]\r\n        file_path = top_result['file_path']\r\n        file_name = top_result['file_name']\r\n        confidence = top_result.get('confidence_score', 0)\r\n        \r\n        # --- NEW: Extract Metadata ---\r\n        app_used = top_result.get('app_used', 'Unknown App')\r\n        timestamp = top_result.get('timestamp', 'Unknown Time')\r\n        duration = top_result.get('duration_seconds', 0)\r\n        # -----------------------------\r\n        \r\n        print(f\"   âœ… Found: {file_name} (confidence: {confidence}%)\")\r\n        \r\n        # Check if file still exists\r\n        if not os.path.exists(file_path):\r\n            print(f\"   âš ï¸ File was moved/deleted: {file_path}\")\r\n            # Try alternate results if top one is missing\r\n            if len(results) > 1:\r\n                for result in results[1:]:\r\n                    if os.path.exists(result['file_path']):\r\n                        file_path = result['file_path']\r\n                        file_name = result['file_name']\r\n                        # Update metadata for the alternate file\r\n                        app_used = result.get('app_used', 'Unknown App')\r\n                        timestamp = result.get('timestamp', 'Unknown Time')\r\n                        duration = result.get('duration_seconds', 0)\r\n                        confidence = result.get('confidence_score', 0)\r\n                        print(f\"   âœ… Using alternate: {file_name}\")\r\n                        break\r\n                else:\r\n                    return {\r\n                        \"status\": \"file_deleted\",\r\n                        \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                    }\r\n            else:\r\n                return {\r\n                    \"status\": \"file_deleted\",\r\n                    \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                }\r\n        \r\n        # Check file size\r\n        try:\r\n            file_size_mb = os.path.getsize(file_path) / (1024 * 1024)\r\n        except:\r\n            file_size_mb = 0\r\n        \r\n        if file_size_mb > 50:\r\n            return {\r\n                \"status\": \"too_large\",\r\n                \"message\": f\"âŒ File is too large to send via Telegram:\\n{file_name}\\n\\nSize: {file_size_mb:.1f} MB (Telegram limit: 50 MB)\\n\\nPath: {file_path}\"\r\n            }\r\n        \r\n        # Success - Return ALL details including new metadata\r\n        return {\r\n            \"status\": \"found\",\r\n            \"file_path\": file_path,\r\n            \"file_name\": file_name,\r\n            \"file_size_mb\": file_size_mb,\r\n            \"confidence\": confidence,\r\n            \"app_used\": app_used,       # <--- Passing this to Telegram\r\n            \"timestamp\": timestamp,     # <--- Passing this to Telegram\r\n            \"duration\": duration,       # <--- Passing this to Telegram\r\n            \"results\": results\r\n        }\r\n        \r\n    except Exception as e:\r\n        error_msg = f\"Error during file search: {e}\"\r\n        print(f\"   âŒ {error_msg}\")\r\n        return {\r\n            \"status\": \"error\",\r\n            \"message\": f\"âŒ Search error: {e}\"\r\n        }",
    "timestamp": "2026-02-04 02:11:07",
    "length": 4524
  },
  {
    "text": "send me that text file from today\r\ntxt\r\nhahahaha.txt\r\n152.0B\r\nâœ… Found: hahahaha.txt\r\nğŸ¯ Confidence: 50.0%\r\n",
    "timestamp": "2026-02-04 01:59:31",
    "length": 106
  },
  {
    "text": "> __:\r\nsend me that text file from today\r\n",
    "timestamp": "2026-02-04 01:58:36",
    "length": 42
  },
  {
    "text": "import logging\r\nimport asyncio\r\nimport os\r\nfrom dotenv import load_dotenv\r\nfrom telegram import Update, constants, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup\r\nfrom telegram.ext import ApplicationBuilder, ContextTypes, MessageHandler, CommandHandler, CallbackQueryHandler, filters\r\nfrom brain import process_command\r\nfrom muscles import execute_command, capture_webcam\r\nimport memory\r\nimport activity_monitor  # Needed to format the output text\r\nimport clipboard_monitor  # For clipboard history\r\nimport file_tracker  # <--- NEW IMPORT: THIS STARTS THE FILE TRACKER AUTOMATICALLY\r\n\r\nload_dotenv()\r\nTOKEN = os.getenv(\"TELEGRAM_TOKEN\")\r\n\r\nif not TOKEN:\r\n    print(\"âŒ Error: TELEGRAM_TOKEN not found in .env file.\")\r\n    exit()\r\n\r\nALLOWED_USERS = [] \r\n\r\nCAMERA_ACTIVE = False\r\n\r\n# FIXED: Changed level to WARNING to stop the console spam\r\nlogging.basicConfig(\r\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\r\n    level=logging.WARNING\r\n)\r\n\r\ndef get_main_keyboard():\r\n    # Combined keyboard: Includes old buttons + new \"/copied_texts\"\r\n    keyboard = [\r\n        [KeyboardButton(\"/screenshot\"), KeyboardButton(\"/sleep\")],\r\n        [KeyboardButton(\"/camera_off\"), KeyboardButton(\"/camera_on\")],\r\n        [KeyboardButton(\"/batterypercentage\"), KeyboardButton(\"/systemhealth\")],\r\n        [KeyboardButton(\"/location\"), KeyboardButton(\"/recordaudio\")],\r\n        [KeyboardButton(\"/clear_bin\"), KeyboardButton(\"/storage\")], \r\n        [KeyboardButton(\"/activities\"), KeyboardButton(\"/copied_texts\")] # <--- ADDED NEW BUTTON\r\n    ]\r\n    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)\r\n\r\nasync def safe_send_action(bot, chat_id, action):\r\n    \"\"\"Safely send chat action (typing/uploading) without crashing on timeout\"\"\"\r\n    try:\r\n        await bot.send_chat_action(chat_id=chat_id, action=action)\r\n    except Exception as e:\r\n        print(f\"âš ï¸ Network Warning: Could not send chat action: {e}\")\r\n\r\nasync def handle_clipboard_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    \"\"\"Handle inline button callbacks for clipboard items\"\"\"\r\n    query = update.callback_query\r\n    await query.answer()\r\n    \r\n    # Extract the clipboard index from callback data (format: \"copy_0\", \"copy_1\", etc.)\r\n    try:\r\n        _, index = query.data.split(\"_\")\r\n        index = int(index)\r\n        \r\n        # Get the clipboard item from the monitor\r\n        item = clipboard_monitor.get_clipboard_item(index)\r\n        \r\n        if item:\r\n            # Copy to user's clipboard by sending as code block (user can tap to copy)\r\n            text = item['text']\r\n            timestamp = item['timestamp']\r\n            \r\n            # Send the text with formatting\r\n            await query.message.reply_text(\r\n                f\"ğŸ“‹ **Copied Text #{index + 1}**\\n\"\r\n                f\"ğŸ• {timestamp}\\n\\n\"\r\n                f\"```\\n{text}\\n```\\n\\n\"\r\n                f\"âœ… _Tap the code block above to copy to your clipboard_\",\r\n                parse_mode='Markdown',\r\n                reply_markup=get_main_keyboard()\r\n            )\r\n        else:\r\n            await query.message.reply_text(\"âŒ Clipboard item not found.\", reply_markup=get_main_keyboard())\r\n            \r\n    except Exception as e:\r\n        print(f\"Error handling clipboard callback: {e}\")\r\n        await query.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nasync def camera_monitor_loop(bot, chat_id):\r\n    global CAMERA_ACTIVE\r\n    try:\r\n        await bot.send_message(chat_id, \"ğŸ”´ Live Feed Started...\")\r\n    except: pass\r\n    \r\n    while CAMERA_ACTIVE:\r\n        photo_path = capture_webcam()\r\n        if photo_path and os.path.exists(photo_path):\r\n            try:\r\n                await bot.send_photo(chat_id, photo=open(photo_path, 'rb'))\r\n            except Exception:\r\n                pass # Ignore network errors during stream\r\n        await asyncio.sleep(3) \r\n    \r\n    try:\r\n        await bot.send_message(chat_id, \"â¹ï¸ Camera Feed Stopped.\")\r\n    except: pass\r\n\r\n\r\nasync def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    user = update.effective_user.first_name\r\n    await update.message.reply_text(\r\n        f\"âš¡ **Pikachu Online!**\\nHello {user}. Use the buttons below.\",\r\n        reply_markup=get_main_keyboard()\r\n    )\r\n\r\nasync def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    global CAMERA_ACTIVE\r\n    user_text = update.message.text\r\n    sender = update.message.from_user.username\r\n    chat_id = update.effective_chat.id\r\n    lower_text = user_text.lower()\r\n    \r\n    print(f\"\\nğŸ“© Message from @{sender}: {user_text}\")\r\n\r\n    # 1. Safe \"Typing\" Indicator (Won't crash if internet lags)\r\n    await safe_send_action(context.bot, chat_id, constants.ChatAction.TYPING)\r\n\r\n    # Pre-process common commands\r\n    command_json = None\r\n    \r\n    if \"/battery\" in lower_text or \"battery\" in lower_text:\r\n        command_json = {\"action\": \"check_battery\"}\r\n    elif \"/systemhealth\" in lower_text or \"system health\" in lower_text:\r\n        command_json = {\"action\": \"check_health\"}\r\n    elif \"/screenshot\" in lower_text or \"screenshot\" in lower_text:\r\n        command_json = {\"action\": \"take_screenshot\"}\r\n    elif \"/sleep\" in lower_text:\r\n        command_json = {\"action\": \"system_sleep\"}\r\n    elif \"/camera_on\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"on\"}\r\n    elif \"/camera_off\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"off\"}\r\n    elif \"/recordaudio\" in lower_text or \"record audio\" in lower_text:\r\n        command_json = {\"action\": \"record_audio\", \"duration\": 10}\r\n    elif \"/location\" in lower_text or any(x in lower_text for x in [\"my location\", \"where am i\", \"laptop location\", \"where is my laptop\", \"find location\"]):\r\n        command_json = {\"action\": \"get_location\"}\r\n    # --- EXISTING BUTTON TRIGGERS ---\r\n    elif \"/clear_bin\" in lower_text or \"clear bin\" in lower_text:\r\n        command_json = {\"action\": \"clear_recycle_bin\"}\r\n    elif \"/storage\" in lower_text or \"check storage\" in lower_text:\r\n        command_json = {\"action\": \"check_storage\"}\r\n    elif \"/activities\" in lower_text or \"activities\" in lower_text:\r\n        command_json = {\"action\": \"get_activities\"}\r\n    # --- NEW CLIPBOARD TRIGGER ---\r\n    elif \"/copied_texts\" in lower_text or any(x in lower_text for x in [\"copied texts\", \"clipboard history\", \"what did i copy\", \"show copied\"]):\r\n        command_json = {\"action\": \"get_clipboard_history\"}\r\n\r\n    # Show processing message (with error handling)\r\n    status_msg = None\r\n    try:\r\n        status_msg = await update.message.reply_text(\"âš¡ Thinking...\", reply_markup=get_main_keyboard())\r\n    except Exception:\r\n        pass # If we can't send \"Thinking\", just continue\r\n\r\n    if not command_json:\r\n        loop = asyncio.get_running_loop()\r\n        try:\r\n            # Use AI to process command\r\n            command_json = await loop.run_in_executor(None, process_command, user_text)\r\n        except Exception as e:\r\n            # If AI fails, send error\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"âŒ Brain Error: {e}\", reply_markup=get_main_keyboard())\r\n            return\r\n\r\n\r\n    if command_json:\r\n        action = command_json.get('action')\r\n        \r\n        # --- ACTIVITIES HANDLER (Supports splitting messages) ---\r\n        if action == \"get_activities\":\r\n            if status_msg: await status_msg.delete()\r\n            # 1. Get raw data from muscles (which calls activity_monitor)\r\n            raw_data = execute_command(command_json)\r\n            \r\n            if raw_data:\r\n                # 2. Format the data using the helper function in activity_monitor\r\n                formatted_message = activity_monitor.format_activities_text(raw_data)\r\n                \r\n                # 3. Send the formatted text - handle both single message and multiple messages\r\n                try:\r\n                    if isinstance(formatted_message, list):\r\n                        # Multiple messages - send each one\r\n                        for i, msg in enumerate(formatted_message):\r\n                            await update.message.reply_text(\r\n                                msg, \r\n                                parse_mode='Markdown', \r\n                                reply_markup=get_main_keyboard() if i == len(formatted_message) - 1 else None\r\n                            )\r\n                            # Small delay between messages to avoid rate limiting\r\n                            if i < len(formatted_message) - 1:\r\n                                await asyncio.sleep(0.5)\r\n                    else:\r\n                        # Single message\r\n                        await update.message.reply_text(formatted_message, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n                except Exception as e:\r\n                    await update.message.reply_text(f\"âŒ Error displaying activities: {e}\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Could not fetch activities.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- NEW: CLIPBOARD HISTORY HANDLER ---\r\n        elif action == \"get_clipboard_history\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Get clipboard history from muscles -> clipboard_monitor\r\n            clipboard_items = execute_command(command_json)\r\n            \r\n            if clipboard_items and len(clipboard_items) > 0:\r\n                # Create inline keyboard with copy buttons for each item\r\n                keyboard = []\r\n                \r\n                # Show up to 20 items\r\n                for i, item in enumerate(clipboard_items[:20]):\r\n                    text = item['text']\r\n                    # Truncate text for button label\r\n                    if len(text) > 50:\r\n                        button_text = text[:47] + \"...\"\r\n                    else:\r\n                        button_text = text\r\n                    \r\n                    # Replace newlines for button display\r\n                    button_text = button_text.replace('\\n', ' ').replace('\\r', '')\r\n                    \r\n                    # Create button with callback data\r\n                    keyboard.append([InlineKeyboardButton(\r\n                        f\"{i+1}. {button_text}\",\r\n                        callback_data=f\"copy_{i}\"\r\n                    )])\r\n                \r\n                reply_markup = InlineKeyboardMarkup(keyboard)\r\n                \r\n                # Send message with buttons\r\n                await update.message.reply_text(\r\n                    f\"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    f\"Found {len(clipboard_items)} copied items.\\n\"\r\n                    f\"Tap any item below to view and copy it:\\n\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=reply_markup\r\n                )\r\n            else:\r\n                await update.message.reply_text(\r\n                    \"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    \"âŒ No copied texts found yet.\\n\"\r\n                    \"Copy some text on your desktop and try again!\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n\r\n        # --- LOCATION TRACKING ---\r\n        elif action == \"get_location\":\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ” Checking multiple location sources...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Get location data\r\n            location_data = execute_command(command_json)\r\n            \r\n            if location_data:\r\n                # Format location message\r\n                location_text = f\"\"\"ğŸŒ **Laptop Location**\r\n\r\nğŸŒ† **Location:** {location_data['city']}, {location_data['region']}\r\nğŸ³ï¸ **Country:** {location_data['country']} ({location_data['country_code']})\r\nğŸ“® **Postal Code:** {location_data['postal']}\r\nğŸŒ **IP Address:** {location_data['ip']}\r\nğŸ“¡ **ISP:** {location_data['org']}\r\nğŸ• **Timezone:** {location_data['timezone']}\r\n\r\nğŸ“Œ **Coordinates:**\r\nLatitude: {location_data['latitude']}\r\nLongitude: {location_data['longitude']}\r\n\r\nğŸ” **Data Source:** {location_data['source']}\r\n\r\nğŸ—ºï¸ [**Open in Google Maps**]({location_data['maps_url']})\r\n\"\"\"\r\n                \r\n                # Add comparison if multiple sources were checked\r\n                if location_data.get('comparison'):\r\n                    location_text += f\"\\n\\nâš ï¸ **Location Comparison:**\\n{location_data['comparison']}\\n\\n_Note: IP-based location may be 50-200km from your actual position. This shows your ISP's server location._\"\r\n                \r\n                await loader.delete()\r\n                \r\n                # Send location as text\r\n                await update.message.reply_text(\r\n                    location_text,\r\n                    parse_mode='Markdown',\r\n                    disable_web_page_preview=False,\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n                \r\n                # Send location on map (Telegram native location)\r\n                try:\r\n                    await update.message.reply_location(\r\n                        latitude=location_data['latitude'],\r\n                        longitude=location_data['longitude'],\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                except Exception as e:\r\n                    print(f\"Could not send map location: {e}\")\r\n                    \r\n            else:\r\n                await loader.edit_text(\"âŒ Failed to get location. Check internet connection.\", reply_markup=get_main_keyboard())\r\n        \r\n        # --- BATTERY CHECK ---\r\n        elif action == \"check_battery\":\r\n            status = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ”‹ {status}\", reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"check_health\":\r\n            report = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(report, reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"take_screenshot\":\r\n            # Screenshot\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ“¸ Capture...\", reply_markup=get_main_keyboard())\r\n            path = execute_command(command_json)\r\n            if path:\r\n                try:\r\n                    await update.message.reply_photo(photo=open(path, 'rb'))\r\n                    await loader.delete()\r\n                except Exception as e:\r\n                    await loader.edit_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                await loader.edit_text(\"âŒ Screenshot failed.\")\r\n                \r\n        elif action == \"system_sleep\":\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(\"ğŸ’¤ Goodnight.\", reply_markup=get_main_keyboard())\r\n            execute_command(command_json)\r\n\r\n        elif action == \"camera_stream\":\r\n            val = command_json.get(\"value\")\r\n            if status_msg: await status_msg.delete()\r\n            if val == \"on\":\r\n                if not CAMERA_ACTIVE:\r\n                    CAMERA_ACTIVE = True\r\n                    asyncio.create_task(camera_monitor_loop(context.bot, chat_id))\r\n            else:\r\n                CAMERA_ACTIVE = False\r\n                await update.message.reply_text(\"ğŸ›‘ Stopping Camera...\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"record_audio\":\r\n            if status_msg: await status_msg.delete()\r\n            duration = command_json.get(\"duration\", 10)\r\n            loader = await update.message.reply_text(f\"ğŸ¤ Recording audio for {duration} seconds...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute audio recording in executor to avoid blocking\r\n            loop = asyncio.get_running_loop()\r\n            audio_path = await loop.run_in_executor(None, execute_command, command_json)\r\n            \r\n            if audio_path and os.path.exists(audio_path):\r\n                try:\r\n                    await loader.delete()\r\n                except:\r\n                    pass  # Ignore if message already deleted\r\n                \r\n                # Send the audio file\r\n                try:\r\n                    await update.message.reply_audio(audio=open(audio_path, 'rb'), caption=\"ğŸµ Recorded Audio (10 seconds)\")\r\n                except Exception as e:\r\n                     await update.message.reply_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                try:\r\n                    await loader.edit_text(\"âŒ Audio recording failed.\")\r\n                except:\r\n                    await update.message.reply_text(\"âŒ Audio recording failed.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"general_chat\":\r\n            response = command_json.get('response', \"...\")\r\n            # AI chat response\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ’¬ {response}\", reply_markup=get_main_keyboard())\r\n\r\n        # --- RECYCLE BIN & STORAGE HANDLERS ---\r\n        elif action == \"clear_recycle_bin\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ—‘ï¸ {result}\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"check_storage\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(result, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n        # --------------------------------------\r\n\r\n        # --- File / App Handling ---\r\n        elif action == \"list_files\":\r\n            if status_msg: await status_msg.delete()\r\n            raw_path = command_json.get('path')\r\n            if \"desktop\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\r\n            elif \"downloads\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\r\n            \r\n            if os.path.exists(raw_path):\r\n                try:\r\n                    files = os.listdir(raw_path)[:20]\r\n                    text = \"\\n\".join([f\"ğŸ“¹ {f}\" for f in files])\r\n                    await update.message.reply_text(f\"ğŸ“‚ **Files:**\\n{text}\", reply_markup=get_main_keyboard())\r\n                except: \r\n                    await update.message.reply_text(\"âŒ Failed to read folder.\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Folder not found.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"send_file\":\r\n             if status_msg: await status_msg.delete()\r\n             raw_path = command_json.get('path')\r\n             if os.path.exists(raw_path):\r\n                 try:\r\n                     await update.message.reply_text(\"ğŸ“¤ Uploading...\", reply_markup=get_main_keyboard())\r\n                     await update.message.reply_document(open(raw_path, 'rb'))\r\n                 except Exception as e:\r\n                     print(f\"Upload Error: {e}\")\r\n                     await update.message.reply_text(\"âŒ Error: File upload timed out or failed.\", reply_markup=get_main_keyboard())\r\n             else:\r\n                 await update.message.reply_text(\"âŒ File not found.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- FIND FILE HANDLER (Context-Aware File Finder) ---\r\n        elif action == \"find_file\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Show searching message\r\n            search_msg = await update.message.reply_text(\"ğŸ” Searching for file...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute file search in background thread\r\n            loop = asyncio.get_running_loop()\r\n            try:\r\n                search_result = await loop.run_in_executor(None, execute_command, command_json)\r\n                \r\n                if not search_result:\r\n                    await search_msg.edit_text(\"âŒ File search failed.\", reply_markup=get_main_keyboard())\r\n                    return\r\n                \r\n                status = search_result.get(\"status\")\r\n                \r\n                if status == \"found\":\r\n                    # File found! Send it\r\n                    file_path = search_result.get(\"file_path\")\r\n                    file_name = search_result.get(\"file_name\")\r\n                    file_size_mb = search_result.get(\"file_size_mb\", 0)\r\n                    confidence = search_result.get(\"confidence\", 0)\r\n                    \r\n                    await search_msg.delete()\r\n                    \r\n                    # Send file size warning if large\r\n                    size_warning = \"\"\r\n                    if file_size_mb > 20:\r\n                        size_warning = f\"\\n\\nâš ï¸ _Large file: {file_size_mb:.1f} MB_\"\r\n                    \r\n                    # Send the file\r\n                    upload_msg = await update.message.reply_text(\r\n                        f\"ğŸ“¤ Uploading: **{file_name}**{size_warning}\",\r\n                        parse_mode='Markdown',\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                    \r\n                    try:\r\n                        await update.message.reply_document(\r\n                            document=open(file_path, 'rb'),\r\n                            caption=f\"âœ… Found: {file_name}\\nğŸ¯ Confidence: {confidence}%\",\r\n                            reply_markup=get_main_keyboard()\r\n                        )\r\n                        await upload_msg.delete()\r\n                        \r\n                        # Update memory with successful file type preference\r\n                        import memory\r\n                        file_ext = os.path.splitext(file_name)[1].replace('.', '').lower()\r\n                        memory.track_file_preference(file_ext)\r\n                        \r\n                    except Exception as e:\r\n                        print(f\"Upload Error: {e}\")\r\n                        await upload_msg.edit_text(f\"âŒ Upload failed: {e}\", reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"not_found\":\r\n                    # No files found\r\n                    message = search_result.get(\"message\", \"No files found.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"file_deleted\":\r\n                    # File was found but doesn't exist anymore\r\n                    message = search_result.get(\"message\", \"File no longer exists.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"too_large\":\r\n                    # File too large for Telegram\r\n                    message = search_result.get(\"message\", \"File too large.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                else:\r\n                    # Unknown status or error\r\n                    message = search_result.get(\"message\", \"Search completed with unknown status.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                    \r\n            except Exception as e:\r\n                print(f\"Find file error: {e}\")\r\n                await search_msg.edit_text(f\"âŒ Search error: {e}\", reply_markup=get_main_keyboard())\r\n        # ---------------------------------------------------------\r\n\r\n        else:\r\n            # Generic action execution\r\n            try:\r\n                execute_command(command_json)\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âœ… Action Complete: {action}\", reply_markup=get_main_keyboard())\r\n            except Exception as e:\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"ğŸš€ TELEGRAM BOT STARTED...\")\r\n    try:\r\n        # Increase connection timeout to handle slow uploads better\r\n        application = ApplicationBuilder().token(TOKEN).read_timeout(60).write_timeout(60).build()\r\n        \r\n        # Add handlers\r\n        application.add_handler(CommandHandler(\"start\", start_command))\r\n        application.add_handler(CallbackQueryHandler(handle_clipboard_callback)) # NEW: Clipboard handler\r\n        application.add_handler(MessageHandler(filters.TEXT | filters.COMMAND, handle_message))\r\n        \r\n        application.run_polling()\r\n    except Exception as e:\r\n        print(f\"âŒ Critical Error: {e}\")",
    "timestamp": "2026-02-04 01:56:10",
    "length": 24919
  },
  {
    "text": " i know its a long line of codes, but please please dont skip anything, please update the code properly that it will work, and please im begging you to dont skip/remove anything those already exists",
    "timestamp": "2026-02-04 01:52:48",
    "length": 198
  },
  {
    "text": "Downloads",
    "timestamp": "2026-02-04 01:52:31",
    "length": 9
  },
  {
    "text": "import logging\r\nimport asyncio\r\nimport os\r\nfrom dotenv import load_dotenv\r\nfrom telegram import Update, constants, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup\r\nfrom telegram.ext import ApplicationBuilder, ContextTypes, MessageHandler, CommandHandler, CallbackQueryHandler, filters\r\nfrom brain import process_command\r\nfrom muscles import execute_command, capture_webcam\r\nimport memory\r\nimport activity_monitor  # Needed to format the output text\r\nimport clipboard_monitor  # <--- NEW IMPORT: For clipboard history\r\n\r\nload_dotenv()\r\nTOKEN = os.getenv(\"TELEGRAM_TOKEN\")\r\n\r\nif not TOKEN:\r\n    print(\"âŒ Error: TELEGRAM_TOKEN not found in .env file.\")\r\n    exit()\r\n\r\nALLOWED_USERS = [] \r\n\r\nCAMERA_ACTIVE = False\r\n\r\nlogging.basicConfig(\r\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\r\n    level=logging.INFO\r\n)\r\n\r\ndef get_main_keyboard():\r\n    # Combined keyboard: Includes old buttons + new \"/copied_texts\"\r\n    keyboard = [\r\n        [KeyboardButton(\"/screenshot\"), KeyboardButton(\"/sleep\")],\r\n        [KeyboardButton(\"/camera_off\"), KeyboardButton(\"/camera_on\")],\r\n        [KeyboardButton(\"/batterypercentage\"), KeyboardButton(\"/systemhealth\")],\r\n        [KeyboardButton(\"/location\"), KeyboardButton(\"/recordaudio\")],\r\n        [KeyboardButton(\"/clear_bin\"), KeyboardButton(\"/storage\")], \r\n        [KeyboardButton(\"/activities\"), KeyboardButton(\"/copied_texts\")] # <--- ADDED NEW BUTTON\r\n    ]\r\n    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)\r\n\r\nasync def safe_send_action(bot, chat_id, action):\r\n    \"\"\"Safely send chat action (typing/uploading) without crashing on timeout\"\"\"\r\n    try:\r\n        await bot.send_chat_action(chat_id=chat_id, action=action)\r\n    except Exception as e:\r\n        print(f\"âš ï¸ Network Warning: Could not send chat action: {e}\")\r\n\r\nasync def handle_clipboard_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    \"\"\"Handle inline button callbacks for clipboard items\"\"\"\r\n    query = update.callback_query\r\n    await query.answer()\r\n    \r\n    # Extract the clipboard index from callback data (format: \"copy_0\", \"copy_1\", etc.)\r\n    try:\r\n        _, index = query.data.split(\"_\")\r\n        index = int(index)\r\n        \r\n        # Get the clipboard item from the monitor\r\n        item = clipboard_monitor.get_clipboard_item(index)\r\n        \r\n        if item:\r\n            # Copy to user's clipboard by sending as code block (user can tap to copy)\r\n            text = item['text']\r\n            timestamp = item['timestamp']\r\n            \r\n            # Send the text with formatting\r\n            await query.message.reply_text(\r\n                f\"ğŸ“‹ **Copied Text #{index + 1}**\\n\"\r\n                f\"ğŸ• {timestamp}\\n\\n\"\r\n                f\"```\\n{text}\\n```\\n\\n\"\r\n                f\"âœ… _Tap the code block above to copy to your clipboard_\",\r\n                parse_mode='Markdown',\r\n                reply_markup=get_main_keyboard()\r\n            )\r\n        else:\r\n            await query.message.reply_text(\"âŒ Clipboard item not found.\", reply_markup=get_main_keyboard())\r\n            \r\n    except Exception as e:\r\n        print(f\"Error handling clipboard callback: {e}\")\r\n        await query.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nasync def camera_monitor_loop(bot, chat_id):\r\n    global CAMERA_ACTIVE\r\n    try:\r\n        await bot.send_message(chat_id, \"ğŸ”´ Live Feed Started...\")\r\n    except: pass\r\n    \r\n    while CAMERA_ACTIVE:\r\n        photo_path = capture_webcam()\r\n        if photo_path and os.path.exists(photo_path):\r\n            try:\r\n                await bot.send_photo(chat_id, photo=open(photo_path, 'rb'))\r\n            except Exception:\r\n                pass # Ignore network errors during stream\r\n        await asyncio.sleep(3) \r\n    \r\n    try:\r\n        await bot.send_message(chat_id, \"â¹ï¸ Camera Feed Stopped.\")\r\n    except: pass\r\n\r\n\r\nasync def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    user = update.effective_user.first_name\r\n    await update.message.reply_text(\r\n        f\"âš¡ **Pikachu Online!**\\nHello {user}. Use the buttons below.\",\r\n        reply_markup=get_main_keyboard()\r\n    )\r\n\r\nasync def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\r\n    global CAMERA_ACTIVE\r\n    user_text = update.message.text\r\n    sender = update.message.from_user.username\r\n    chat_id = update.effective_chat.id\r\n    lower_text = user_text.lower()\r\n    \r\n    print(f\"\\nğŸ“© Message from @{sender}: {user_text}\")\r\n\r\n    # 1. Safe \"Typing\" Indicator (Won't crash if internet lags)\r\n    await safe_send_action(context.bot, chat_id, constants.ChatAction.TYPING)\r\n\r\n    # Pre-process common commands\r\n    command_json = None\r\n    \r\n    if \"/battery\" in lower_text or \"battery\" in lower_text:\r\n        command_json = {\"action\": \"check_battery\"}\r\n    elif \"/systemhealth\" in lower_text or \"system health\" in lower_text:\r\n        command_json = {\"action\": \"check_health\"}\r\n    elif \"/screenshot\" in lower_text or \"screenshot\" in lower_text:\r\n        command_json = {\"action\": \"take_screenshot\"}\r\n    elif \"/sleep\" in lower_text:\r\n        command_json = {\"action\": \"system_sleep\"}\r\n    elif \"/camera_on\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"on\"}\r\n    elif \"/camera_off\" in lower_text:\r\n        command_json = {\"action\": \"camera_stream\", \"value\": \"off\"}\r\n    elif \"/recordaudio\" in lower_text or \"record audio\" in lower_text:\r\n        command_json = {\"action\": \"record_audio\", \"duration\": 10}\r\n    elif \"/location\" in lower_text or any(x in lower_text for x in [\"my location\", \"where am i\", \"laptop location\", \"where is my laptop\", \"find location\"]):\r\n        command_json = {\"action\": \"get_location\"}\r\n    # --- EXISTING BUTTON TRIGGERS ---\r\n    elif \"/clear_bin\" in lower_text or \"clear bin\" in lower_text:\r\n        command_json = {\"action\": \"clear_recycle_bin\"}\r\n    elif \"/storage\" in lower_text or \"check storage\" in lower_text:\r\n        command_json = {\"action\": \"check_storage\"}\r\n    elif \"/activities\" in lower_text or \"activities\" in lower_text:\r\n        command_json = {\"action\": \"get_activities\"}\r\n    # --- NEW CLIPBOARD TRIGGER ---\r\n    elif \"/copied_texts\" in lower_text or any(x in lower_text for x in [\"copied texts\", \"clipboard history\", \"what did i copy\", \"show copied\"]):\r\n        command_json = {\"action\": \"get_clipboard_history\"}\r\n\r\n    # Show processing message (with error handling)\r\n    status_msg = None\r\n    try:\r\n        status_msg = await update.message.reply_text(\"âš¡ Thinking...\", reply_markup=get_main_keyboard())\r\n    except Exception:\r\n        pass # If we can't send \"Thinking\", just continue\r\n\r\n    if not command_json:\r\n        loop = asyncio.get_running_loop()\r\n        try:\r\n            # Use AI to process command\r\n            command_json = await loop.run_in_executor(None, process_command, user_text)\r\n        except Exception as e:\r\n            # If AI fails, send error\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"âŒ Brain Error: {e}\", reply_markup=get_main_keyboard())\r\n            return\r\n\r\n\r\n    if command_json:\r\n        action = command_json.get('action')\r\n        \r\n        # --- ACTIVITIES HANDLER (Supports splitting messages) ---\r\n        if action == \"get_activities\":\r\n            if status_msg: await status_msg.delete()\r\n            # 1. Get raw data from muscles (which calls activity_monitor)\r\n            raw_data = execute_command(command_json)\r\n            \r\n            if raw_data:\r\n                # 2. Format the data using the helper function in activity_monitor\r\n                formatted_message = activity_monitor.format_activities_text(raw_data)\r\n                \r\n                # 3. Send the formatted text - handle both single message and multiple messages\r\n                try:\r\n                    if isinstance(formatted_message, list):\r\n                        # Multiple messages - send each one\r\n                        for i, msg in enumerate(formatted_message):\r\n                            await update.message.reply_text(\r\n                                msg, \r\n                                parse_mode='Markdown', \r\n                                reply_markup=get_main_keyboard() if i == len(formatted_message) - 1 else None\r\n                            )\r\n                            # Small delay between messages to avoid rate limiting\r\n                            if i < len(formatted_message) - 1:\r\n                                await asyncio.sleep(0.5)\r\n                    else:\r\n                        # Single message\r\n                        await update.message.reply_text(formatted_message, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n                except Exception as e:\r\n                    await update.message.reply_text(f\"âŒ Error displaying activities: {e}\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Could not fetch activities.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- NEW: CLIPBOARD HISTORY HANDLER ---\r\n        elif action == \"get_clipboard_history\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Get clipboard history from muscles -> clipboard_monitor\r\n            clipboard_items = execute_command(command_json)\r\n            \r\n            if clipboard_items and len(clipboard_items) > 0:\r\n                # Create inline keyboard with copy buttons for each item\r\n                keyboard = []\r\n                \r\n                # Show up to 20 items\r\n                for i, item in enumerate(clipboard_items[:20]):\r\n                    text = item['text']\r\n                    # Truncate text for button label\r\n                    if len(text) > 50:\r\n                        button_text = text[:47] + \"...\"\r\n                    else:\r\n                        button_text = text\r\n                    \r\n                    # Replace newlines for button display\r\n                    button_text = button_text.replace('\\n', ' ').replace('\\r', '')\r\n                    \r\n                    # Create button with callback data\r\n                    keyboard.append([InlineKeyboardButton(\r\n                        f\"{i+1}. {button_text}\",\r\n                        callback_data=f\"copy_{i}\"\r\n                    )])\r\n                \r\n                reply_markup = InlineKeyboardMarkup(keyboard)\r\n                \r\n                # Send message with buttons\r\n                await update.message.reply_text(\r\n                    f\"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    f\"Found {len(clipboard_items)} copied items.\\n\"\r\n                    f\"Tap any item below to view and copy it:\\n\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=reply_markup\r\n                )\r\n            else:\r\n                await update.message.reply_text(\r\n                    \"ğŸ“‹ **CLIPBOARD HISTORY**\\n\\n\"\r\n                    \"âŒ No copied texts found yet.\\n\"\r\n                    \"Copy some text on your desktop and try again!\",\r\n                    parse_mode='Markdown',\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n\r\n        # --- LOCATION TRACKING ---\r\n        elif action == \"get_location\":\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ” Checking multiple location sources...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Get location data\r\n            location_data = execute_command(command_json)\r\n            \r\n            if location_data:\r\n                # Format location message\r\n                location_text = f\"\"\"ğŸŒ **Laptop Location**\r\n\r\nğŸŒ† **Location:** {location_data['city']}, {location_data['region']}\r\nğŸ³ï¸ **Country:** {location_data['country']} ({location_data['country_code']})\r\nğŸ“® **Postal Code:** {location_data['postal']}\r\nğŸŒ **IP Address:** {location_data['ip']}\r\nğŸ“¡ **ISP:** {location_data['org']}\r\nğŸ• **Timezone:** {location_data['timezone']}\r\n\r\nğŸ“Œ **Coordinates:**\r\nLatitude: {location_data['latitude']}\r\nLongitude: {location_data['longitude']}\r\n\r\nğŸ” **Data Source:** {location_data['source']}\r\n\r\nğŸ—ºï¸ [**Open in Google Maps**]({location_data['maps_url']})\r\n\"\"\"\r\n                \r\n                # Add comparison if multiple sources were checked\r\n                if location_data.get('comparison'):\r\n                    location_text += f\"\\n\\nâš ï¸ **Location Comparison:**\\n{location_data['comparison']}\\n\\n_Note: IP-based location may be 50-200km from your actual position. This shows your ISP's server location._\"\r\n                \r\n                await loader.delete()\r\n                \r\n                # Send location as text\r\n                await update.message.reply_text(\r\n                    location_text,\r\n                    parse_mode='Markdown',\r\n                    disable_web_page_preview=False,\r\n                    reply_markup=get_main_keyboard()\r\n                )\r\n                \r\n                # Send location on map (Telegram native location)\r\n                try:\r\n                    await update.message.reply_location(\r\n                        latitude=location_data['latitude'],\r\n                        longitude=location_data['longitude'],\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                except Exception as e:\r\n                    print(f\"Could not send map location: {e}\")\r\n                    \r\n            else:\r\n                await loader.edit_text(\"âŒ Failed to get location. Check internet connection.\", reply_markup=get_main_keyboard())\r\n        \r\n        # --- BATTERY CHECK ---\r\n        elif action == \"check_battery\":\r\n            status = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ”‹ {status}\", reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"check_health\":\r\n            report = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(report, reply_markup=get_main_keyboard())\r\n            \r\n        elif action == \"take_screenshot\":\r\n            # Screenshot\r\n            if status_msg: await status_msg.delete()\r\n            loader = await update.message.reply_text(\"ğŸ“¸ Capture...\", reply_markup=get_main_keyboard())\r\n            path = execute_command(command_json)\r\n            if path:\r\n                try:\r\n                    await update.message.reply_photo(photo=open(path, 'rb'))\r\n                    await loader.delete()\r\n                except Exception as e:\r\n                    await loader.edit_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                await loader.edit_text(\"âŒ Screenshot failed.\")\r\n                \r\n        elif action == \"system_sleep\":\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(\"ğŸ’¤ Goodnight.\", reply_markup=get_main_keyboard())\r\n            execute_command(command_json)\r\n\r\n        elif action == \"camera_stream\":\r\n            val = command_json.get(\"value\")\r\n            if status_msg: await status_msg.delete()\r\n            if val == \"on\":\r\n                if not CAMERA_ACTIVE:\r\n                    CAMERA_ACTIVE = True\r\n                    asyncio.create_task(camera_monitor_loop(context.bot, chat_id))\r\n            else:\r\n                CAMERA_ACTIVE = False\r\n                await update.message.reply_text(\"ğŸ›‘ Stopping Camera...\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"record_audio\":\r\n            if status_msg: await status_msg.delete()\r\n            duration = command_json.get(\"duration\", 10)\r\n            loader = await update.message.reply_text(f\"ğŸ¤ Recording audio for {duration} seconds...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute audio recording in executor to avoid blocking\r\n            loop = asyncio.get_running_loop()\r\n            audio_path = await loop.run_in_executor(None, execute_command, command_json)\r\n            \r\n            if audio_path and os.path.exists(audio_path):\r\n                try:\r\n                    await loader.delete()\r\n                except:\r\n                    pass  # Ignore if message already deleted\r\n                \r\n                # Send the audio file\r\n                try:\r\n                    await update.message.reply_audio(audio=open(audio_path, 'rb'), caption=\"ğŸµ Recorded Audio (10 seconds)\")\r\n                except Exception as e:\r\n                     await update.message.reply_text(f\"âŒ Upload Failed: {e}\")\r\n            else:\r\n                try:\r\n                    await loader.edit_text(\"âŒ Audio recording failed.\")\r\n                except:\r\n                    await update.message.reply_text(\"âŒ Audio recording failed.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"general_chat\":\r\n            response = command_json.get('response', \"...\")\r\n            # AI chat response\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ’¬ {response}\", reply_markup=get_main_keyboard())\r\n\r\n        # --- RECYCLE BIN & STORAGE HANDLERS ---\r\n        elif action == \"clear_recycle_bin\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(f\"ğŸ—‘ï¸ {result}\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"check_storage\":\r\n            result = execute_command(command_json)\r\n            if status_msg: await status_msg.delete()\r\n            await update.message.reply_text(result, parse_mode='Markdown', reply_markup=get_main_keyboard())\r\n        # --------------------------------------\r\n\r\n        # --- File / App Handling ---\r\n        elif action == \"list_files\":\r\n            if status_msg: await status_msg.delete()\r\n            raw_path = command_json.get('path')\r\n            if \"desktop\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\r\n            elif \"downloads\" in raw_path.lower(): raw_path = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\r\n            \r\n            if os.path.exists(raw_path):\r\n                try:\r\n                    files = os.listdir(raw_path)[:20]\r\n                    text = \"\\n\".join([f\"ğŸ“¹ {f}\" for f in files])\r\n                    await update.message.reply_text(f\"ğŸ“‚ **Files:**\\n{text}\", reply_markup=get_main_keyboard())\r\n                except: \r\n                    await update.message.reply_text(\"âŒ Failed to read folder.\", reply_markup=get_main_keyboard())\r\n            else:\r\n                await update.message.reply_text(\"âŒ Folder not found.\", reply_markup=get_main_keyboard())\r\n\r\n        elif action == \"send_file\":\r\n             if status_msg: await status_msg.delete()\r\n             raw_path = command_json.get('path')\r\n             if os.path.exists(raw_path):\r\n                 try:\r\n                     await update.message.reply_text(\"ğŸ“¤ Uploading...\", reply_markup=get_main_keyboard())\r\n                     await update.message.reply_document(open(raw_path, 'rb'))\r\n                 except Exception as e:\r\n                     print(f\"Upload Error: {e}\")\r\n                     await update.message.reply_text(\"âŒ Error: File upload timed out or failed.\", reply_markup=get_main_keyboard())\r\n             else:\r\n                 await update.message.reply_text(\"âŒ File not found.\", reply_markup=get_main_keyboard())\r\n\r\n        # --- FIND FILE HANDLER (Context-Aware File Finder) ---\r\n        elif action == \"find_file\":\r\n            if status_msg: await status_msg.delete()\r\n            \r\n            # Show searching message\r\n            search_msg = await update.message.reply_text(\"ğŸ” Searching for file...\", reply_markup=get_main_keyboard())\r\n            \r\n            # Execute file search in background thread\r\n            loop = asyncio.get_running_loop()\r\n            try:\r\n                search_result = await loop.run_in_executor(None, execute_command, command_json)\r\n                \r\n                if not search_result:\r\n                    await search_msg.edit_text(\"âŒ File search failed.\", reply_markup=get_main_keyboard())\r\n                    return\r\n                \r\n                status = search_result.get(\"status\")\r\n                \r\n                if status == \"found\":\r\n                    # File found! Send it\r\n                    file_path = search_result.get(\"file_path\")\r\n                    file_name = search_result.get(\"file_name\")\r\n                    file_size_mb = search_result.get(\"file_size_mb\", 0)\r\n                    confidence = search_result.get(\"confidence\", 0)\r\n                    \r\n                    await search_msg.delete()\r\n                    \r\n                    # Send file size warning if large\r\n                    size_warning = \"\"\r\n                    if file_size_mb > 20:\r\n                        size_warning = f\"\\n\\nâš ï¸ _Large file: {file_size_mb:.1f} MB_\"\r\n                    \r\n                    # Send the file\r\n                    upload_msg = await update.message.reply_text(\r\n                        f\"ğŸ“¤ Uploading: **{file_name}**{size_warning}\",\r\n                        parse_mode='Markdown',\r\n                        reply_markup=get_main_keyboard()\r\n                    )\r\n                    \r\n                    try:\r\n                        await update.message.reply_document(\r\n                            document=open(file_path, 'rb'),\r\n                            caption=f\"âœ… Found: {file_name}\\nğŸ¯ Confidence: {confidence}%\",\r\n                            reply_markup=get_main_keyboard()\r\n                        )\r\n                        await upload_msg.delete()\r\n                        \r\n                        # Update memory with successful file type preference\r\n                        import memory\r\n                        file_ext = os.path.splitext(file_name)[1].replace('.', '').lower()\r\n                        memory.track_file_preference(file_ext)\r\n                        \r\n                    except Exception as e:\r\n                        print(f\"Upload Error: {e}\")\r\n                        await upload_msg.edit_text(f\"âŒ Upload failed: {e}\", reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"not_found\":\r\n                    # No files found\r\n                    message = search_result.get(\"message\", \"No files found.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"file_deleted\":\r\n                    # File was found but doesn't exist anymore\r\n                    message = search_result.get(\"message\", \"File no longer exists.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                elif status == \"too_large\":\r\n                    # File too large for Telegram\r\n                    message = search_result.get(\"message\", \"File too large.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                \r\n                else:\r\n                    # Unknown status or error\r\n                    message = search_result.get(\"message\", \"Search completed with unknown status.\")\r\n                    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n                    \r\n            except Exception as e:\r\n                print(f\"Find file error: {e}\")\r\n                await search_msg.edit_text(f\"âŒ Search error: {e}\", reply_markup=get_main_keyboard())\r\n        # ---------------------------------------------------------\r\n\r\n        else:\r\n            # Generic action execution\r\n            try:\r\n                execute_command(command_json)\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âœ… Action Complete: {action}\", reply_markup=get_main_keyboard())\r\n            except Exception as e:\r\n                if status_msg: await status_msg.delete()\r\n                await update.message.reply_text(f\"âŒ Error: {e}\", reply_markup=get_main_keyboard())\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"ğŸš€ TELEGRAM BOT STARTED...\")\r\n    try:\r\n        # Increase connection timeout to handle slow uploads better\r\n        application = ApplicationBuilder().token(TOKEN).read_timeout(60).write_timeout(60).build()\r\n        \r\n        # Add handlers\r\n        application.add_handler(CommandHandler(\"start\", start_command))\r\n        application.add_handler(CallbackQueryHandler(handle_clipboard_callback)) # NEW: Clipboard handler\r\n        application.add_handler(MessageHandler(filters.TEXT | filters.COMMAND, handle_message))\r\n        \r\n        application.run_polling()\r\n    except Exception as e:\r\n        print(f\"âŒ Critical Error: {e}\")",
    "timestamp": "2026-02-04 01:52:06",
    "length": 24789
  },
  {
    "text": "\"\"\"\r\nFile Tracker Module for Pikachu Desktop Assistant\r\nTracks all file opens/access in real-time and logs activity\r\n\"\"\"\r\n\r\nimport os\r\nimport json\r\nimport time\r\nimport threading\r\nfrom datetime import datetime, timedelta\r\nfrom collections import defaultdict\r\nimport win32gui\r\nimport win32process\r\nimport psutil\r\n\r\n# Configuration\r\nFILE_ACTIVITY_LOG = \"file_activity_log.json\"\r\nMAX_LOG_DAYS = 30  # Keep last 30 days of activity\r\nCHECK_INTERVAL = 2  # Check every 2 seconds\r\n\r\n# Global state\r\nfile_activity_log = []\r\ntracking_active = False\r\ntracker_thread = None\r\ncurrently_open_files = {}  # Track files currently being accessed\r\n\r\n# System/temp paths to ignore\r\nIGNORE_PATHS = [\r\n    \"\\\\AppData\\\\Local\\\\Temp\",\r\n    \"\\\\Windows\\\\\",\r\n    \"\\\\System32\\\\\",\r\n    \"\\\\Program Files\\\\\",\r\n    \"\\\\ProgramData\\\\\",\r\n    \"\\\\$Recycle.Bin\",\r\n    \"\\\\.git\",\r\n    \"\\\\node_modules\",\r\n    \"\\\\venv\\\\\",\r\n    \"\\\\__pycache__\",\r\n]\r\n\r\n# File extensions we care about\r\nTRACKED_EXTENSIONS = [\r\n    # Documents\r\n    '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt',\r\n    # Spreadsheets\r\n    '.xlsx', '.xls', '.csv', '.ods',\r\n    # Presentations\r\n    '.pptx', '.ppt', '.odp',\r\n    # Images\r\n    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp',\r\n    # Videos\r\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv',\r\n    # Audio\r\n    '.mp3', '.wav', '.flac', '.aac', '.ogg',\r\n    # Code\r\n    '.py', '.js', '.java', '.cpp', '.c', '.html', '.css', '.json', '.xml',\r\n    # Archives\r\n    '.zip', '.rar', '.7z', '.tar', '.gz',\r\n    # Others\r\n    '.exe', '.msi', '.apk', '.dmg'\r\n]\r\n\r\n\r\ndef load_activity_log():\r\n    \"\"\"Load existing activity log from file\"\"\"\r\n    global file_activity_log\r\n    \r\n    if os.path.exists(FILE_ACTIVITY_LOG):\r\n        try:\r\n            with open(FILE_ACTIVITY_LOG, 'r', encoding='utf-8') as f:\r\n                file_activity_log = json.load(f)\r\n                print(f\"ğŸ“ Loaded {len(file_activity_log)} file activity records\")\r\n        except Exception as e:\r\n            print(f\"Error loading file activity log: {e}\")\r\n            file_activity_log = []\r\n    else:\r\n        file_activity_log = []\r\n        # Create empty file immediately to ensure it exists\r\n        save_activity_log()\r\n\r\n\r\ndef save_activity_log():\r\n    \"\"\"Save activity log to file\"\"\"\r\n    try:\r\n        with open(FILE_ACTIVITY_LOG, 'w', encoding='utf-8') as f:\r\n            json.dump(file_activity_log, f, indent=2, ensure_ascii=False)\r\n    except Exception as e:\r\n        print(f\"Error saving file activity log: {e}\")\r\n\r\n\r\ndef should_ignore_file(file_path):\r\n    \"\"\"Check if file should be ignored based on path or extension\"\"\"\r\n    if not file_path or not isinstance(file_path, str):\r\n        return True\r\n    \r\n    # Ignore system/temp paths\r\n    for ignore_path in IGNORE_PATHS:\r\n        if ignore_path.lower() in file_path.lower():\r\n            return True\r\n    \r\n    # Check if extension is tracked\r\n    _, ext = os.path.splitext(file_path)\r\n    if ext.lower() not in TRACKED_EXTENSIONS:\r\n        return True\r\n    \r\n    return False\r\n\r\n\r\ndef get_active_window_file():\r\n    \"\"\"Get file path from currently active window using multiple detection methods\"\"\"\r\n    try:\r\n        # Get active window handle\r\n        hwnd = win32gui.GetForegroundWindow()\r\n        if not hwnd:\r\n            return None, None\r\n        \r\n        # Get window title\r\n        window_title = win32gui.GetWindowText(hwnd)\r\n        if not window_title:\r\n            return None, None\r\n            \r\n        # Get process ID\r\n        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n        \r\n        # Get process info\r\n        try:\r\n            process = psutil.Process(pid)\r\n            app_name = process.name()\r\n            potential_paths = []\r\n\r\n            # DEBUG: Un-comment this line if you want to see every window check in console\r\n            # print(f\"[DEBUG] Checking: '{window_title}' ({app_name})\")\r\n\r\n            # --- METHOD 1: Command Line Arguments (Most Reliable for Notepad, etc.) ---\r\n            try:\r\n                cmdline = process.cmdline()\r\n                if cmdline:\r\n                    # Skip the first argument (executable itself)\r\n                    for arg in cmdline[1:]:\r\n                        clean_arg = arg.strip('\"').strip(\"'\")\r\n                        if os.path.exists(clean_arg) and os.path.isfile(clean_arg):\r\n                             # FIX: Get filename without extension to match Notepad titles\r\n                             filename = os.path.basename(clean_arg)      # e.g., \"hahahaha.txt\"\r\n                             name_no_ext = os.path.splitext(filename)[0] # e.g., \"hahahaha\"\r\n                             \r\n                             # Check if either full name OR name without extension is in title\r\n                             if (name_no_ext.lower() in window_title.lower()) or (filename.lower() in window_title.lower()) or len(cmdline) == 2:\r\n                                 potential_paths.append(clean_arg)\r\n            except (psutil.AccessDenied, IndexError, Exception):\r\n                pass\r\n\r\n            # --- METHOD 2: Open Files Handle (Reliable if Admin, flaky otherwise) ---\r\n            try:\r\n                open_files = process.open_files()\r\n                for f in open_files:\r\n                    if not should_ignore_file(f.path):\r\n                        filename = os.path.basename(f.path)\r\n                        name_no_ext = os.path.splitext(filename)[0]\r\n                        \r\n                        # FIX: Check if name without extension is in title\r\n                        if name_no_ext.lower() in window_title.lower():\r\n                            potential_paths.append(f.path)\r\n            except (psutil.AccessDenied, psutil.NoSuchProcess):\r\n                pass\r\n\r\n            # --- METHOD 3: Window Title Parsing (Fallback) ---\r\n            if ':\\\\' in window_title:\r\n                parts = window_title.split(' ')\r\n                for part in parts:\r\n                    if ':\\\\' in part and os.path.exists(part):\r\n                         potential_paths.append(part)\r\n\r\n            # --- FINAL SELECTION ---\r\n            for path in potential_paths:\r\n                if not should_ignore_file(path):\r\n                    # print(f\"[DEBUG] MATCH FOUND: {path}\")  # Debug print\r\n                    return path, app_name\r\n                \r\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n            pass\r\n    \r\n    except Exception as e:\r\n        print(f\"[DEBUG] Error in detector: {e}\")\r\n    \r\n    return None, None\r\n\r\n\r\ndef log_file_activity(file_path, app_name, duration=None):\r\n    \"\"\"Log file access activity\"\"\"\r\n    global file_activity_log\r\n    \r\n    if should_ignore_file(file_path):\r\n        return\r\n    \r\n    # Create log entry\r\n    entry = {\r\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\r\n        'file_path': file_path,\r\n        'file_name': os.path.basename(file_path),\r\n        'file_type': os.path.splitext(file_path)[1].lower().replace('.', ''),\r\n        'app_used': app_name,\r\n        'duration_seconds': duration if duration else 0\r\n    }\r\n    \r\n    # Check if this is a duplicate of the most recent entry\r\n    if file_activity_log:\r\n        last_entry = file_activity_log[-1]\r\n        # If same file accessed within 5 minutes, update duration instead of adding new entry\r\n        if (last_entry['file_path'] == file_path and \r\n            last_entry['app_used'] == app_name):\r\n            \r\n            last_time = datetime.strptime(last_entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            current_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            time_diff = (current_time - last_time).total_seconds()\r\n            \r\n            if time_diff < 300:  # 5 minutes\r\n                # Update existing entry's duration\r\n                last_entry['duration_seconds'] = int(time_diff)\r\n                save_activity_log()\r\n                return\r\n    \r\n    # Add new entry\r\n    file_activity_log.append(entry)\r\n    \r\n    # FIXED: Save immediately after adding new entry\r\n    save_activity_log()\r\n    \r\n    print(f\"ğŸ“ Tracked: {entry['file_name']} ({app_name})\")\r\n\r\n\r\ndef track_files():\r\n    \"\"\"Background thread that tracks file activity\"\"\"\r\n    global tracking_active, currently_open_files\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking started...\")\r\n    \r\n    # Ensure log file exists at start\r\n    if not os.path.exists(FILE_ACTIVITY_LOG):\r\n        print(\"[DEBUG] Creating initial JSON log file...\")\r\n        save_activity_log()\r\n    \r\n    while tracking_active:\r\n        try:\r\n            # Get currently active file\r\n            file_path, app_name = get_active_window_file()\r\n            \r\n            current_time = time.time()\r\n            \r\n            if file_path and app_name:\r\n                # Track when file was opened\r\n                file_key = f\"{file_path}|{app_name}\"\r\n                \r\n                if file_key not in currently_open_files:\r\n                    # New file opened\r\n                    currently_open_files[file_key] = {\r\n                        'path': file_path,\r\n                        'app': app_name,\r\n                        'start_time': current_time\r\n                    }\r\n                    log_file_activity(file_path, app_name)\r\n                else:\r\n                    # File still open, calculate duration\r\n                    start_t = currently_open_files[file_key]['start_time']\r\n                    duration = int(current_time - start_t)\r\n                    \r\n                    if duration > 0 and duration % 30 == 0:  # Log every 30 seconds\r\n                        log_file_activity(file_path, app_name, duration)\r\n            \r\n            # Clean up closed files\r\n            closed_files = []\r\n            for file_key, info in currently_open_files.items():\r\n                # If the current active file is NOT this file, consider it \"closed\"\r\n                if file_path != info['path']:\r\n                    closed_files.append(file_key)\r\n            \r\n            for file_key in closed_files:\r\n                del currently_open_files[file_key]\r\n            \r\n            # Check every N seconds\r\n            time.sleep(CHECK_INTERVAL)\r\n            \r\n        except Exception as e:\r\n            # Silently handle errors\r\n            print(f\"File tracking error: {e}\")\r\n            time.sleep(CHECK_INTERVAL)\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking stopped.\")\r\n\r\n\r\ndef start_tracking():\r\n    \"\"\"Start the file tracking thread\"\"\"\r\n    global tracking_active, tracker_thread\r\n    \r\n    if tracking_active:\r\n        print(\"âš ï¸ File tracking already active\")\r\n        return\r\n    \r\n    # Load existing log\r\n    load_activity_log()\r\n    \r\n    # Cleanup old logs\r\n    cleanup_old_logs(MAX_LOG_DAYS)\r\n    \r\n    # Start tracking\r\n    tracking_active = True\r\n    tracker_thread = threading.Thread(target=track_files, daemon=True)\r\n    tracker_thread.start()\r\n    \r\n    print(\"âœ… File tracking activated\")\r\n\r\n\r\ndef stop_tracking():\r\n    \"\"\"Stop the file tracking thread\"\"\"\r\n    global tracking_active\r\n    \r\n    tracking_active = False\r\n    save_activity_log()\r\n    print(\"ğŸ›‘ File tracking deactivated\")\r\n\r\n\r\ndef get_recent_files(hours=24, file_type=None):\r\n    \"\"\"Get files accessed in the last N hours, optionally filtered by type\"\"\"\r\n    cutoff_time = datetime.now() - timedelta(hours=hours)\r\n    recent_files = []\r\n    \r\n    for entry in reversed(file_activity_log):  # Start from most recent\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if entry_time < cutoff_time:\r\n            break  # Stop if we've gone past the time range\r\n        \r\n        # Filter by file type if specified\r\n        if file_type and entry['file_type'] != file_type.lower():\r\n            continue\r\n        \r\n        recent_files.append(entry)\r\n    \r\n    return recent_files\r\n\r\n\r\ndef get_files_by_timerange(start_time, end_time):\r\n    \"\"\"Get files accessed within a specific time range\"\"\"\r\n    files_in_range = []\r\n    \r\n    for entry in file_activity_log:\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if start_time <= entry_time <= end_time:\r\n            files_in_range.append(entry)\r\n    \r\n    return files_in_range\r\n\r\n\r\ndef cleanup_old_logs(days=30):\r\n    \"\"\"Remove log entries older than N days\"\"\"\r\n    global file_activity_log\r\n    \r\n    cutoff_date = datetime.now() - timedelta(days=days)\r\n    original_count = len(file_activity_log)\r\n    \r\n    file_activity_log = [\r\n        entry for entry in file_activity_log\r\n        if datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S') > cutoff_date\r\n    ]\r\n    \r\n    removed_count = original_count - len(file_activity_log)\r\n    \r\n    if removed_count > 0:\r\n        print(f\"ğŸ—‘ï¸ Cleaned up {removed_count} old file activity records\")\r\n        save_activity_log()\r\n\r\n\r\ndef format_file_activity_text(entries, limit=20):\r\n    \"\"\"Format file activity as readable text for display\"\"\"\r\n    if not entries:\r\n        return \"ğŸ“ **FILE ACTIVITY**\\n\\nâŒ No file activity found.\"\r\n    \r\n    entries = entries[:limit]  # Limit results\r\n    lines = [f\"ğŸ“ **FILE ACTIVITY** (Last {len(entries)} files)\\n\"]\r\n    \r\n    for i, entry in enumerate(entries, 1):\r\n        file_name = entry['file_name']\r\n        timestamp = entry['timestamp']\r\n        app_used = entry['app_used']\r\n        duration = entry.get('duration_seconds', 0)\r\n        \r\n        duration_str = f\"{duration}s\" if duration > 0 else \"\"\r\n        \r\n        lines.append(f\"{i}. **{file_name}**\")\r\n        lines.append(f\"   ğŸ“… {timestamp} | ğŸ“± {app_used} {duration_str}\")\r\n        lines.append(f\"   ğŸ“‚ {entry['file_path']}\\n\")\r\n    \r\n    return \"\\n\".join(lines)\r\n\r\n\r\n# Auto-start tracking when module is imported\r\nstart_tracking()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Test the module\r\n    print(\"Testing file tracker...\")\r\n    print(\"Open some files to test tracking...\")\r\n    \r\n    # Keep main thread alive for testing\r\n    try:\r\n        while True:\r\n            time.sleep(1)\r\n    except KeyboardInterrupt:\r\n        stop_tracking()",
    "timestamp": "2026-02-04 01:45:06",
    "length": 14001
  },
  {
    "text": " i know its a long line of codes, but please please dont skip anything, please update the code properly that it will work, and please im begging you to dont skip/remove anything those already exists",
    "timestamp": "2026-02-04 01:43:35",
    "length": 198
  },
  {
    "text": "\"\"\"\r\nFile Tracker Module for Pikachu Desktop Assistant\r\nTracks all file opens/access in real-time and logs activity\r\n\"\"\"\r\n\r\nimport os\r\nimport json\r\nimport time\r\nimport threading\r\nfrom datetime import datetime, timedelta\r\nfrom collections import defaultdict\r\nimport win32gui\r\nimport win32process\r\nimport psutil\r\n\r\n# Configuration\r\nFILE_ACTIVITY_LOG = \"file_activity_log.json\"\r\nMAX_LOG_DAYS = 30  # Keep last 30 days of activity\r\nCHECK_INTERVAL = 2  # Check every 2 seconds\r\n\r\n# Global state\r\nfile_activity_log = []\r\ntracking_active = False\r\ntracker_thread = None\r\ncurrently_open_files = {}  # Track files currently being accessed\r\n\r\n# System/temp paths to ignore\r\nIGNORE_PATHS = [\r\n    \"\\\\AppData\\\\Local\\\\Temp\",\r\n    \"\\\\Windows\\\\\",\r\n    \"\\\\System32\\\\\",\r\n    \"\\\\Program Files\\\\\",\r\n    \"\\\\ProgramData\\\\\",\r\n    \"\\\\$Recycle.Bin\",\r\n    \"\\\\.git\",\r\n    \"\\\\node_modules\",\r\n    \"\\\\venv\\\\\",\r\n    \"\\\\__pycache__\",\r\n]\r\n\r\n# File extensions we care about\r\nTRACKED_EXTENSIONS = [\r\n    # Documents\r\n    '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt',\r\n    # Spreadsheets\r\n    '.xlsx', '.xls', '.csv', '.ods',\r\n    # Presentations\r\n    '.pptx', '.ppt', '.odp',\r\n    # Images\r\n    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp',\r\n    # Videos\r\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv',\r\n    # Audio\r\n    '.mp3', '.wav', '.flac', '.aac', '.ogg',\r\n    # Code\r\n    '.py', '.js', '.java', '.cpp', '.c', '.html', '.css', '.json', '.xml',\r\n    # Archives\r\n    '.zip', '.rar', '.7z', '.tar', '.gz',\r\n    # Others\r\n    '.exe', '.msi', '.apk', '.dmg'\r\n]\r\n\r\n\r\ndef load_activity_log():\r\n    \"\"\"Load existing activity log from file\"\"\"\r\n    global file_activity_log\r\n    \r\n    if os.path.exists(FILE_ACTIVITY_LOG):\r\n        try:\r\n            with open(FILE_ACTIVITY_LOG, 'r', encoding='utf-8') as f:\r\n                file_activity_log = json.load(f)\r\n                print(f\"ğŸ“ Loaded {len(file_activity_log)} file activity records\")\r\n        except Exception as e:\r\n            print(f\"Error loading file activity log: {e}\")\r\n            file_activity_log = []\r\n    else:\r\n        file_activity_log = []\r\n        # Create empty file immediately to ensure it exists\r\n        save_activity_log()\r\n\r\n\r\ndef save_activity_log():\r\n    \"\"\"Save activity log to file\"\"\"\r\n    try:\r\n        with open(FILE_ACTIVITY_LOG, 'w', encoding='utf-8') as f:\r\n            json.dump(file_activity_log, f, indent=2, ensure_ascii=False)\r\n    except Exception as e:\r\n        print(f\"Error saving file activity log: {e}\")\r\n\r\n\r\ndef should_ignore_file(file_path):\r\n    \"\"\"Check if file should be ignored based on path or extension\"\"\"\r\n    if not file_path or not isinstance(file_path, str):\r\n        return True\r\n    \r\n    # Ignore system/temp paths\r\n    for ignore_path in IGNORE_PATHS:\r\n        if ignore_path.lower() in file_path.lower():\r\n            return True\r\n    \r\n    # Check if extension is tracked\r\n    _, ext = os.path.splitext(file_path)\r\n    if ext.lower() not in TRACKED_EXTENSIONS:\r\n        return True\r\n    \r\n    return False\r\n\r\n\r\ndef get_active_window_file():\r\n    \"\"\"Get file path from currently active window using multiple detection methods\"\"\"\r\n    try:\r\n        # Get active window handle\r\n        hwnd = win32gui.GetForegroundWindow()\r\n        if not hwnd:\r\n            return None, None\r\n        \r\n        # Get window title\r\n        window_title = win32gui.GetWindowText(hwnd)\r\n        if not window_title:\r\n            return None, None\r\n            \r\n        # Get process ID\r\n        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n        \r\n        # Get process info\r\n        try:\r\n            process = psutil.Process(pid)\r\n            app_name = process.name()\r\n            potential_paths = []\r\n\r\n            # --- METHOD 1: Command Line Arguments (Most Reliable for Notepad, etc.) ---\r\n            # Many apps are launched as \"app.exe C:\\path\\to\\file.txt\"\r\n            try:\r\n                cmdline = process.cmdline()\r\n                if cmdline:\r\n                    # Skip the first argument (executable itself)\r\n                    for arg in cmdline[1:]:\r\n                        clean_arg = arg.strip('\"').strip(\"'\")\r\n                        if os.path.exists(clean_arg) and os.path.isfile(clean_arg):\r\n                             # Verify the filename appears in the window title (to avoid background files)\r\n                             # or if it's the only argument, trust it.\r\n                             filename = os.path.basename(clean_arg)\r\n                             if filename.lower() in window_title.lower() or len(cmdline) == 2:\r\n                                 potential_paths.append(clean_arg)\r\n            except (psutil.AccessDenied, IndexError, Exception):\r\n                pass\r\n\r\n            # --- METHOD 2: Open Files Handle (Reliable if Admin, flaky otherwise) ---\r\n            try:\r\n                open_files = process.open_files()\r\n                for f in open_files:\r\n                    if not should_ignore_file(f.path):\r\n                        # Check if filename appears in window title to confirm it's the active tab\r\n                        filename = os.path.basename(f.path)\r\n                        if filename.lower() in window_title.lower():\r\n                            potential_paths.append(f.path)\r\n            except (psutil.AccessDenied, psutil.NoSuchProcess):\r\n                pass\r\n\r\n            # --- METHOD 3: Window Title Parsing (Fallback) ---\r\n            if ':\\\\' in window_title:\r\n                # Basic heuristic: look for substrings containing \":\\\"\r\n                parts = window_title.split(' ')\r\n                for part in parts:\r\n                    if ':\\\\' in part and os.path.exists(part):\r\n                         potential_paths.append(part)\r\n\r\n            # --- FINAL SELECTION ---\r\n            # Return the first valid path found\r\n            for path in potential_paths:\r\n                if not should_ignore_file(path):\r\n                    return path, app_name\r\n                \r\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n            pass\r\n    \r\n    except Exception as e:\r\n        # Silently handle errors\r\n        pass\r\n    \r\n    return None, None\r\n\r\n\r\ndef log_file_activity(file_path, app_name, duration=None):\r\n    \"\"\"Log file access activity\"\"\"\r\n    global file_activity_log\r\n    \r\n    if should_ignore_file(file_path):\r\n        return\r\n    \r\n    # Create log entry\r\n    entry = {\r\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\r\n        'file_path': file_path,\r\n        'file_name': os.path.basename(file_path),\r\n        'file_type': os.path.splitext(file_path)[1].lower().replace('.', ''),\r\n        'app_used': app_name,\r\n        'duration_seconds': duration if duration else 0\r\n    }\r\n    \r\n    # Check if this is a duplicate of the most recent entry\r\n    if file_activity_log:\r\n        last_entry = file_activity_log[-1]\r\n        # If same file accessed within 5 minutes, update duration instead of adding new entry\r\n        if (last_entry['file_path'] == file_path and \r\n            last_entry['app_used'] == app_name):\r\n            \r\n            last_time = datetime.strptime(last_entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            current_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            time_diff = (current_time - last_time).total_seconds()\r\n            \r\n            if time_diff < 300:  # 5 minutes\r\n                # Update existing entry's duration\r\n                last_entry['duration_seconds'] = int(time_diff)\r\n                save_activity_log()\r\n                return\r\n    \r\n    # Add new entry\r\n    file_activity_log.append(entry)\r\n    \r\n    # FIXED: Save immediately after adding new entry\r\n    save_activity_log()\r\n    \r\n    print(f\"ğŸ“ Tracked: {entry['file_name']} ({app_name})\")\r\n\r\n\r\ndef track_files():\r\n    \"\"\"Background thread that tracks file activity\"\"\"\r\n    global tracking_active, currently_open_files\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking started...\")\r\n    \r\n    # Ensure log file exists at start\r\n    if not os.path.exists(FILE_ACTIVITY_LOG):\r\n        save_activity_log()\r\n    \r\n    while tracking_active:\r\n        try:\r\n            # Get currently active file\r\n            file_path, app_name = get_active_window_file()\r\n            \r\n            current_time = time.time()\r\n            \r\n            if file_path and app_name:\r\n                # Track when file was opened\r\n                file_key = f\"{file_path}|{app_name}\"\r\n                \r\n                if file_key not in currently_open_files:\r\n                    # New file opened\r\n                    currently_open_files[file_key] = {\r\n                        'path': file_path,\r\n                        'app': app_name,\r\n                        'start_time': current_time\r\n                    }\r\n                    log_file_activity(file_path, app_name)\r\n                else:\r\n                    # File still open, calculate duration\r\n                    start_t = currently_open_files[file_key]['start_time']\r\n                    duration = int(current_time - start_t)\r\n                    \r\n                    if duration > 0 and duration % 30 == 0:  # Log every 30 seconds\r\n                        log_file_activity(file_path, app_name, duration)\r\n            \r\n            # Clean up closed files\r\n            closed_files = []\r\n            for file_key, info in currently_open_files.items():\r\n                # If the current active file is NOT this file, consider it \"closed\" or inactive for now\r\n                if file_path != info['path']:\r\n                    closed_files.append(file_key)\r\n            \r\n            for file_key in closed_files:\r\n                del currently_open_files[file_key]\r\n            \r\n            # Check every N seconds\r\n            time.sleep(CHECK_INTERVAL)\r\n            \r\n        except Exception as e:\r\n            # Silently handle errors\r\n            print(f\"File tracking error: {e}\")\r\n            time.sleep(CHECK_INTERVAL)\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking stopped.\")\r\n\r\n\r\ndef start_tracking():\r\n    \"\"\"Start the file tracking thread\"\"\"\r\n    global tracking_active, tracker_thread\r\n    \r\n    if tracking_active:\r\n        print(\"âš ï¸ File tracking already active\")\r\n        return\r\n    \r\n    # Load existing log\r\n    load_activity_log()\r\n    \r\n    # Cleanup old logs\r\n    cleanup_old_logs(MAX_LOG_DAYS)\r\n    \r\n    # Start tracking\r\n    tracking_active = True\r\n    tracker_thread = threading.Thread(target=track_files, daemon=True)\r\n    tracker_thread.start()\r\n    \r\n    print(\"âœ… File tracking activated\")\r\n\r\n\r\ndef stop_tracking():\r\n    \"\"\"Stop the file tracking thread\"\"\"\r\n    global tracking_active\r\n    \r\n    tracking_active = False\r\n    save_activity_log()\r\n    print(\"ğŸ›‘ File tracking deactivated\")\r\n\r\n\r\ndef get_recent_files(hours=24, file_type=None):\r\n    \"\"\"Get files accessed in the last N hours, optionally filtered by type\"\"\"\r\n    cutoff_time = datetime.now() - timedelta(hours=hours)\r\n    recent_files = []\r\n    \r\n    for entry in reversed(file_activity_log):  # Start from most recent\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if entry_time < cutoff_time:\r\n            break  # Stop if we've gone past the time range\r\n        \r\n        # Filter by file type if specified\r\n        if file_type and entry['file_type'] != file_type.lower():\r\n            continue\r\n        \r\n        recent_files.append(entry)\r\n    \r\n    return recent_files\r\n\r\n\r\ndef get_files_by_timerange(start_time, end_time):\r\n    \"\"\"Get files accessed within a specific time range\"\"\"\r\n    files_in_range = []\r\n    \r\n    for entry in file_activity_log:\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if start_time <= entry_time <= end_time:\r\n            files_in_range.append(entry)\r\n    \r\n    return files_in_range\r\n\r\n\r\ndef cleanup_old_logs(days=30):\r\n    \"\"\"Remove log entries older than N days\"\"\"\r\n    global file_activity_log\r\n    \r\n    cutoff_date = datetime.now() - timedelta(days=days)\r\n    original_count = len(file_activity_log)\r\n    \r\n    file_activity_log = [\r\n        entry for entry in file_activity_log\r\n        if datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S') > cutoff_date\r\n    ]\r\n    \r\n    removed_count = original_count - len(file_activity_log)\r\n    \r\n    if removed_count > 0:\r\n        print(f\"ğŸ—‘ï¸ Cleaned up {removed_count} old file activity records\")\r\n        save_activity_log()\r\n\r\n\r\ndef format_file_activity_text(entries, limit=20):\r\n    \"\"\"Format file activity as readable text for display\"\"\"\r\n    if not entries:\r\n        return \"ğŸ“ **FILE ACTIVITY**\\n\\nâŒ No file activity found.\"\r\n    \r\n    entries = entries[:limit]  # Limit results\r\n    lines = [f\"ğŸ“ **FILE ACTIVITY** (Last {len(entries)} files)\\n\"]\r\n    \r\n    for i, entry in enumerate(entries, 1):\r\n        file_name = entry['file_name']\r\n        timestamp = entry['timestamp']\r\n        app_used = entry['app_used']\r\n        duration = entry.get('duration_seconds', 0)\r\n        \r\n        duration_str = f\"{duration}s\" if duration > 0 else \"\"\r\n        \r\n        lines.append(f\"{i}. **{file_name}**\")\r\n        lines.append(f\"   ğŸ“… {timestamp} | ğŸ“± {app_used} {duration_str}\")\r\n        lines.append(f\"   ğŸ“‚ {entry['file_path']}\\n\")\r\n    \r\n    return \"\\n\".join(lines)\r\n\r\n\r\n# Auto-start tracking when module is imported\r\nstart_tracking()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Test the module\r\n    print(\"Testing file tracker...\")\r\n    print(\"Open some files to test tracking...\")\r\n    \r\n    # Keep main thread alive for testing\r\n    try:\r\n        while True:\r\n            time.sleep(1)\r\n    except KeyboardInterrupt:\r\n        stop_tracking()",
    "timestamp": "2026-02-04 01:43:10",
    "length": 13623
  },
  {
    "text": "\"\"\"\r\nFile Tracker Module for Pikachu Desktop Assistant\r\nTracks all file opens/access in real-time and logs activity\r\n\"\"\"\r\n\r\nimport os\r\nimport json\r\nimport time\r\nimport threading\r\nfrom datetime import datetime, timedelta\r\nimport win32gui\r\nimport win32process\r\nimport psutil\r\n\r\n# Configuration\r\nFILE_ACTIVITY_LOG = \"file_activity_log.json\"\r\nMAX_LOG_DAYS = 30\r\nCHECK_INTERVAL = 2\r\n\r\n# Global state\r\nfile_activity_log = []\r\ntracking_active = False\r\ntracker_thread = None\r\ncurrently_open_files = {}\r\n\r\nIGNORE_PATHS = [\r\n    \"\\\\AppData\\\\Local\\\\Temp\",\r\n    \"\\\\Windows\\\\\",\r\n    \"\\\\System32\\\\\",\r\n    \"\\\\Program Files\\\\\",\r\n    \"\\\\ProgramData\\\\\",\r\n    \"\\\\$Recycle.Bin\",\r\n    \"\\\\.git\",\r\n    \"\\\\node_modules\",\r\n    \"\\\\venv\\\\\",\r\n    \"\\\\__pycache__\",\r\n]\r\n\r\nTRACKED_EXTENSIONS = [\r\n    '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt',\r\n    '.xlsx', '.xls', '.csv', '.ods',\r\n    '.pptx', '.ppt', '.odp',\r\n    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp',\r\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv',\r\n    '.mp3', '.wav', '.flac', '.aac', '.ogg',\r\n    '.py', '.js', '.java', '.cpp', '.c', '.html', '.css', '.json', '.xml',\r\n    '.zip', '.rar', '.7z', '.tar', '.gz',\r\n]\r\n\r\ndef load_activity_log():\r\n    global file_activity_log\r\n    if os.path.exists(FILE_ACTIVITY_LOG):\r\n        try:\r\n            with open(FILE_ACTIVITY_LOG, 'r', encoding='utf-8') as f:\r\n                file_activity_log = json.load(f)\r\n        except Exception as e:\r\n            print(f\"Error loading log: {e}\")\r\n            file_activity_log = []\r\n    else:\r\n        file_activity_log = []\r\n        # Create the file immediately if it doesn't exist\r\n        save_activity_log()\r\n\r\ndef save_activity_log():\r\n    try:\r\n        with open(FILE_ACTIVITY_LOG, 'w', encoding='utf-8') as f:\r\n            json.dump(file_activity_log, f, indent=2, ensure_ascii=False)\r\n        # Verify file creation\r\n        if not os.path.exists(FILE_ACTIVITY_LOG):\r\n            print(\"âŒ ERROR: Failed to create JSON file!\")\r\n    except Exception as e:\r\n        print(f\"Error saving log: {e}\")\r\n\r\ndef should_ignore_file(file_path):\r\n    if not file_path or not isinstance(file_path, str):\r\n        return True\r\n    \r\n    for ignore_path in IGNORE_PATHS:\r\n        if ignore_path.lower() in file_path.lower():\r\n            return True\r\n    \r\n    _, ext = os.path.splitext(file_path)\r\n    if ext.lower() not in TRACKED_EXTENSIONS:\r\n        return True\r\n    \r\n    return False\r\n\r\ndef get_active_window_file():\r\n    \"\"\"Debug-enabled file detector\"\"\"\r\n    try:\r\n        hwnd = win32gui.GetForegroundWindow()\r\n        if not hwnd: return None, None\r\n        \r\n        window_title = win32gui.GetWindowText(hwnd)\r\n        if not window_title: return None, None\r\n        \r\n        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n        \r\n        try:\r\n            process = psutil.Process(pid)\r\n            app_name = process.name()\r\n            \r\n            # DEBUG PRINT: Uncomment the next line to see every window check\r\n            # print(f\"ğŸ” Checking Window: '{window_title}' ({app_name})\")\r\n\r\n            potential_paths = []\r\n\r\n            # Method 1: Command Line Arguments\r\n            try:\r\n                cmdline = process.cmdline()\r\n                if cmdline:\r\n                    for arg in cmdline[1:]:\r\n                        clean_arg = arg.strip('\"').strip(\"'\")\r\n                        if os.path.exists(clean_arg) and os.path.isfile(clean_arg):\r\n                            \r\n                            # LOGIC FIX: Check filename WITHOUT extension against window title\r\n                            filename = os.path.basename(clean_arg)     # \"hahahaha.txt\"\r\n                            name_no_ext = os.path.splitext(filename)[0] # \"hahahaha\"\r\n                            \r\n                            # Check if \"hahahaha\" is in \"hahahaha - Notepad\"\r\n                            if name_no_ext.lower() in window_title.lower() or len(cmdline) == 2:\r\n                                potential_paths.append(clean_arg)\r\n            except Exception:\r\n                pass\r\n\r\n            # Method 2: Open Files (Fallback)\r\n            try:\r\n                open_files = process.open_files()\r\n                for f in open_files:\r\n                    if not should_ignore_file(f.path):\r\n                        filename = os.path.basename(f.path)\r\n                        name_no_ext = os.path.splitext(filename)[0]\r\n                        if name_no_ext.lower() in window_title.lower():\r\n                            potential_paths.append(f.path)\r\n            except Exception:\r\n                pass\r\n\r\n            # Return valid path\r\n            for path in potential_paths:\r\n                if not should_ignore_file(path):\r\n                    # print(f\"   âœ… MATCH FOUND: {path}\")\r\n                    return path, app_name\r\n                \r\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n            pass\r\n    \r\n    except Exception as e:\r\n        print(f\"Tracker Error: {e}\")\r\n    \r\n    return None, None\r\n\r\ndef log_file_activity(file_path, app_name, duration=None):\r\n    global file_activity_log\r\n    \r\n    if should_ignore_file(file_path): return\r\n    \r\n    entry = {\r\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\r\n        'file_path': file_path,\r\n        'file_name': os.path.basename(file_path),\r\n        'file_type': os.path.splitext(file_path)[1].lower().replace('.', ''),\r\n        'app_used': app_name,\r\n        'duration_seconds': duration if duration else 0\r\n    }\r\n    \r\n    # Update duration if duplicate\r\n    if file_activity_log:\r\n        last_entry = file_activity_log[-1]\r\n        if (last_entry['file_path'] == file_path and last_entry['app_used'] == app_name):\r\n            last_time = datetime.strptime(last_entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            current_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            time_diff = (current_time - last_time).total_seconds()\r\n            if time_diff < 300:\r\n                last_entry['duration_seconds'] = int(time_diff)\r\n                save_activity_log()\r\n                return\r\n    \r\n    file_activity_log.append(entry)\r\n    save_activity_log()\r\n    print(f\"ğŸ“ LOGGED: {entry['file_name']}\")\r\n\r\ndef track_files():\r\n    global tracking_active, currently_open_files\r\n    print(\"ğŸ‘ï¸ Tracker: Running...\")\r\n    \r\n    # Ensure JSON exists immediately\r\n    if not os.path.exists(FILE_ACTIVITY_LOG):\r\n        print(\"Creating new log file...\")\r\n        save_activity_log()\r\n    \r\n    while tracking_active:\r\n        try:\r\n            file_path, app_name = get_active_window_file()\r\n            current_time = time.time()\r\n            \r\n            if file_path and app_name:\r\n                file_key = f\"{file_path}|{app_name}\"\r\n                if file_key not in currently_open_files:\r\n                    currently_open_files[file_key] = {'path': file_path, 'start_time': current_time}\r\n                    log_file_activity(file_path, app_name)\r\n                else:\r\n                    # Update duration every 10 seconds\r\n                    duration = int(current_time - currently_open_files[file_key]['start_time'])\r\n                    if duration > 0 and duration % 10 == 0:\r\n                        log_file_activity(file_path, app_name, duration)\r\n            \r\n            # Cleanup\r\n            closed = [k for k, v in currently_open_files.items() if file_path != v['path']]\r\n            for k in closed: del currently_open_files[k]\r\n            \r\n            time.sleep(CHECK_INTERVAL)\r\n        except Exception as e:\r\n            print(f\"Loop Error: {e}\")\r\n            time.sleep(CHECK_INTERVAL)\r\n\r\ndef start_tracking():\r\n    global tracking_active, tracker_thread\r\n    if tracking_active: return\r\n    load_activity_log()\r\n    tracking_active = True\r\n    tracker_thread = threading.Thread(target=track_files, daemon=True)\r\n    tracker_thread.start()\r\n    print(\"âœ… Tracker Thread Started\")\r\n\r\ndef stop_tracking():\r\n    global tracking_active\r\n    tracking_active = False\r\n    save_activity_log()\r\n\r\n# Auto-start\r\nstart_tracking()\r\n\r\n# Keep alive if run directly\r\nif __name__ == \"__main__\":\r\n    print(\"Debug Mode: ON. Open a file now.\")\r\n    try:\r\n        while True: time.sleep(1)\r\n    except KeyboardInterrupt:\r\n        stop_tracking()",
    "timestamp": "2026-02-04 01:42:53",
    "length": 8262
  },
  {
    "text": "\"\"\"\r\nFile Tracker Module for Pikachu Desktop Assistant\r\nTracks all file opens/access in real-time and logs activity\r\n\"\"\"\r\n\r\nimport os\r\nimport json\r\nimport time\r\nimport threading\r\nfrom datetime import datetime, timedelta\r\nfrom collections import defaultdict\r\nimport win32gui\r\nimport win32process\r\nimport psutil\r\n\r\n# Configuration\r\nFILE_ACTIVITY_LOG = \"file_activity_log.json\"\r\nMAX_LOG_DAYS = 30  # Keep last 30 days of activity\r\nCHECK_INTERVAL = 2  # Check every 2 seconds\r\n\r\n# Global state\r\nfile_activity_log = []\r\ntracking_active = False\r\ntracker_thread = None\r\ncurrently_open_files = {}  # Track files currently being accessed\r\n\r\n# System/temp paths to ignore\r\nIGNORE_PATHS = [\r\n    \"\\\\AppData\\\\Local\\\\Temp\",\r\n    \"\\\\Windows\\\\\",\r\n    \"\\\\System32\\\\\",\r\n    \"\\\\Program Files\\\\\",\r\n    \"\\\\ProgramData\\\\\",\r\n    \"\\\\$Recycle.Bin\",\r\n    \"\\\\.git\",\r\n    \"\\\\node_modules\",\r\n    \"\\\\venv\\\\\",\r\n    \"\\\\__pycache__\",\r\n]\r\n\r\n# File extensions we care about\r\nTRACKED_EXTENSIONS = [\r\n    # Documents\r\n    '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt',\r\n    # Spreadsheets\r\n    '.xlsx', '.xls', '.csv', '.ods',\r\n    # Presentations\r\n    '.pptx', '.ppt', '.odp',\r\n    # Images\r\n    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp',\r\n    # Videos\r\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv',\r\n    # Audio\r\n    '.mp3', '.wav', '.flac', '.aac', '.ogg',\r\n    # Code\r\n    '.py', '.js', '.java', '.cpp', '.c', '.html', '.css', '.json', '.xml',\r\n    # Archives\r\n    '.zip', '.rar', '.7z', '.tar', '.gz',\r\n    # Others\r\n    '.exe', '.msi', '.apk', '.dmg'\r\n]\r\n\r\n\r\ndef load_activity_log():\r\n    \"\"\"Load existing activity log from file\"\"\"\r\n    global file_activity_log\r\n    \r\n    if os.path.exists(FILE_ACTIVITY_LOG):\r\n        try:\r\n            with open(FILE_ACTIVITY_LOG, 'r', encoding='utf-8') as f:\r\n                file_activity_log = json.load(f)\r\n                print(f\"ğŸ“ Loaded {len(file_activity_log)} file activity records\")\r\n        except Exception as e:\r\n            print(f\"Error loading file activity log: {e}\")\r\n            file_activity_log = []\r\n    else:\r\n        file_activity_log = []\r\n        # Create empty file immediately to ensure it exists\r\n        save_activity_log()\r\n\r\n\r\ndef save_activity_log():\r\n    \"\"\"Save activity log to file\"\"\"\r\n    try:\r\n        with open(FILE_ACTIVITY_LOG, 'w', encoding='utf-8') as f:\r\n            json.dump(file_activity_log, f, indent=2, ensure_ascii=False)\r\n    except Exception as e:\r\n        print(f\"Error saving file activity log: {e}\")\r\n\r\n\r\ndef should_ignore_file(file_path):\r\n    \"\"\"Check if file should be ignored based on path or extension\"\"\"\r\n    if not file_path or not isinstance(file_path, str):\r\n        return True\r\n    \r\n    # Ignore system/temp paths\r\n    for ignore_path in IGNORE_PATHS:\r\n        if ignore_path.lower() in file_path.lower():\r\n            return True\r\n    \r\n    # Check if extension is tracked\r\n    _, ext = os.path.splitext(file_path)\r\n    if ext.lower() not in TRACKED_EXTENSIONS:\r\n        return True\r\n    \r\n    return False\r\n\r\n\r\ndef get_active_window_file():\r\n    \"\"\"Get file path from currently active window using multiple detection methods\"\"\"\r\n    try:\r\n        # Get active window handle\r\n        hwnd = win32gui.GetForegroundWindow()\r\n        if not hwnd:\r\n            return None, None\r\n        \r\n        # Get window title\r\n        window_title = win32gui.GetWindowText(hwnd)\r\n        if not window_title:\r\n            return None, None\r\n            \r\n        # Get process ID\r\n        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n        \r\n        # Get process info\r\n        try:\r\n            process = psutil.Process(pid)\r\n            app_name = process.name()\r\n            potential_paths = []\r\n\r\n            # --- METHOD 1: Command Line Arguments (Most Reliable for Notepad, etc.) ---\r\n            # Many apps are launched as \"app.exe C:\\path\\to\\file.txt\"\r\n            try:\r\n                cmdline = process.cmdline()\r\n                if cmdline:\r\n                    # Skip the first argument (executable itself)\r\n                    for arg in cmdline[1:]:\r\n                        clean_arg = arg.strip('\"').strip(\"'\")\r\n                        if os.path.exists(clean_arg) and os.path.isfile(clean_arg):\r\n                             # Verify the filename appears in the window title (to avoid background files)\r\n                             # or if it's the only argument, trust it.\r\n                             filename = os.path.basename(clean_arg)\r\n                             if filename.lower() in window_title.lower() or len(cmdline) == 2:\r\n                                 potential_paths.append(clean_arg)\r\n            except (psutil.AccessDenied, IndexError, Exception):\r\n                pass\r\n\r\n            # --- METHOD 2: Open Files Handle (Reliable if Admin, flaky otherwise) ---\r\n            try:\r\n                open_files = process.open_files()\r\n                for f in open_files:\r\n                    if not should_ignore_file(f.path):\r\n                        # Check if filename appears in window title to confirm it's the active tab\r\n                        filename = os.path.basename(f.path)\r\n                        if filename.lower() in window_title.lower():\r\n                            potential_paths.append(f.path)\r\n            except (psutil.AccessDenied, psutil.NoSuchProcess):\r\n                pass\r\n\r\n            # --- METHOD 3: Window Title Parsing (Fallback) ---\r\n            if ':\\\\' in window_title:\r\n                # Basic heuristic: look for substrings containing \":\\\"\r\n                parts = window_title.split(' ')\r\n                for part in parts:\r\n                    if ':\\\\' in part and os.path.exists(part):\r\n                         potential_paths.append(part)\r\n\r\n            # --- FINAL SELECTION ---\r\n            # Return the first valid path found\r\n            for path in potential_paths:\r\n                if not should_ignore_file(path):\r\n                    return path, app_name\r\n                \r\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n            pass\r\n    \r\n    except Exception as e:\r\n        # Silently handle errors\r\n        pass\r\n    \r\n    return None, None\r\n\r\n\r\ndef log_file_activity(file_path, app_name, duration=None):\r\n    \"\"\"Log file access activity\"\"\"\r\n    global file_activity_log\r\n    \r\n    if should_ignore_file(file_path):\r\n        return\r\n    \r\n    # Create log entry\r\n    entry = {\r\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\r\n        'file_path': file_path,\r\n        'file_name': os.path.basename(file_path),\r\n        'file_type': os.path.splitext(file_path)[1].lower().replace('.', ''),\r\n        'app_used': app_name,\r\n        'duration_seconds': duration if duration else 0\r\n    }\r\n    \r\n    # Check if this is a duplicate of the most recent entry\r\n    if file_activity_log:\r\n        last_entry = file_activity_log[-1]\r\n        # If same file accessed within 5 minutes, update duration instead of adding new entry\r\n        if (last_entry['file_path'] == file_path and \r\n            last_entry['app_used'] == app_name):\r\n            \r\n            last_time = datetime.strptime(last_entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            current_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            time_diff = (current_time - last_time).total_seconds()\r\n            \r\n            if time_diff < 300:  # 5 minutes\r\n                # Update existing entry's duration\r\n                last_entry['duration_seconds'] = int(time_diff)\r\n                save_activity_log()\r\n                return\r\n    \r\n    # Add new entry\r\n    file_activity_log.append(entry)\r\n    \r\n    # FIXED: Save immediately after adding new entry\r\n    save_activity_log()\r\n    \r\n    print(f\"ğŸ“ Tracked: {entry['file_name']} ({app_name})\")\r\n\r\n\r\ndef track_files():\r\n    \"\"\"Background thread that tracks file activity\"\"\"\r\n    global tracking_active, currently_open_files\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking started...\")\r\n    \r\n    # Ensure log file exists at start\r\n    if not os.path.exists(FILE_ACTIVITY_LOG):\r\n        save_activity_log()\r\n    \r\n    while tracking_active:\r\n        try:\r\n            # Get currently active file\r\n            file_path, app_name = get_active_window_file()\r\n            \r\n            current_time = time.time()\r\n            \r\n            if file_path and app_name:\r\n                # Track when file was opened\r\n                file_key = f\"{file_path}|{app_name}\"\r\n                \r\n                if file_key not in currently_open_files:\r\n                    # New file opened\r\n                    currently_open_files[file_key] = {\r\n                        'path': file_path,\r\n                        'app': app_name,\r\n                        'start_time': current_time\r\n                    }\r\n                    log_file_activity(file_path, app_name)\r\n                else:\r\n                    # File still open, calculate duration\r\n                    start_t = currently_open_files[file_key]['start_time']\r\n                    duration = int(current_time - start_t)\r\n                    \r\n                    if duration > 0 and duration % 30 == 0:  # Log every 30 seconds\r\n                        log_file_activity(file_path, app_name, duration)\r\n            \r\n            # Clean up closed files\r\n            closed_files = []\r\n            for file_key, info in currently_open_files.items():\r\n                # If the current active file is NOT this file, consider it \"closed\" or inactive for now\r\n                if file_path != info['path']:\r\n                    closed_files.append(file_key)\r\n            \r\n            for file_key in closed_files:\r\n                del currently_open_files[file_key]\r\n            \r\n            # Check every N seconds\r\n            time.sleep(CHECK_INTERVAL)\r\n            \r\n        except Exception as e:\r\n            # Silently handle errors\r\n            print(f\"File tracking error: {e}\")\r\n            time.sleep(CHECK_INTERVAL)\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking stopped.\")\r\n\r\n\r\ndef start_tracking():\r\n    \"\"\"Start the file tracking thread\"\"\"\r\n    global tracking_active, tracker_thread\r\n    \r\n    if tracking_active:\r\n        print(\"âš ï¸ File tracking already active\")\r\n        return\r\n    \r\n    # Load existing log\r\n    load_activity_log()\r\n    \r\n    # Cleanup old logs\r\n    cleanup_old_logs(MAX_LOG_DAYS)\r\n    \r\n    # Start tracking\r\n    tracking_active = True\r\n    tracker_thread = threading.Thread(target=track_files, daemon=True)\r\n    tracker_thread.start()\r\n    \r\n    print(\"âœ… File tracking activated\")\r\n\r\n\r\ndef stop_tracking():\r\n    \"\"\"Stop the file tracking thread\"\"\"\r\n    global tracking_active\r\n    \r\n    tracking_active = False\r\n    save_activity_log()\r\n    print(\"ğŸ›‘ File tracking deactivated\")\r\n\r\n\r\ndef get_recent_files(hours=24, file_type=None):\r\n    \"\"\"Get files accessed in the last N hours, optionally filtered by type\"\"\"\r\n    cutoff_time = datetime.now() - timedelta(hours=hours)\r\n    recent_files = []\r\n    \r\n    for entry in reversed(file_activity_log):  # Start from most recent\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if entry_time < cutoff_time:\r\n            break  # Stop if we've gone past the time range\r\n        \r\n        # Filter by file type if specified\r\n        if file_type and entry['file_type'] != file_type.lower():\r\n            continue\r\n        \r\n        recent_files.append(entry)\r\n    \r\n    return recent_files\r\n\r\n\r\ndef get_files_by_timerange(start_time, end_time):\r\n    \"\"\"Get files accessed within a specific time range\"\"\"\r\n    files_in_range = []\r\n    \r\n    for entry in file_activity_log:\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if start_time <= entry_time <= end_time:\r\n            files_in_range.append(entry)\r\n    \r\n    return files_in_range\r\n\r\n\r\ndef cleanup_old_logs(days=30):\r\n    \"\"\"Remove log entries older than N days\"\"\"\r\n    global file_activity_log\r\n    \r\n    cutoff_date = datetime.now() - timedelta(days=days)\r\n    original_count = len(file_activity_log)\r\n    \r\n    file_activity_log = [\r\n        entry for entry in file_activity_log\r\n        if datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S') > cutoff_date\r\n    ]\r\n    \r\n    removed_count = original_count - len(file_activity_log)\r\n    \r\n    if removed_count > 0:\r\n        print(f\"ğŸ—‘ï¸ Cleaned up {removed_count} old file activity records\")\r\n        save_activity_log()\r\n\r\n\r\ndef format_file_activity_text(entries, limit=20):\r\n    \"\"\"Format file activity as readable text for display\"\"\"\r\n    if not entries:\r\n        return \"ğŸ“ **FILE ACTIVITY**\\n\\nâŒ No file activity found.\"\r\n    \r\n    entries = entries[:limit]  # Limit results\r\n    lines = [f\"ğŸ“ **FILE ACTIVITY** (Last {len(entries)} files)\\n\"]\r\n    \r\n    for i, entry in enumerate(entries, 1):\r\n        file_name = entry['file_name']\r\n        timestamp = entry['timestamp']\r\n        app_used = entry['app_used']\r\n        duration = entry.get('duration_seconds', 0)\r\n        \r\n        duration_str = f\"{duration}s\" if duration > 0 else \"\"\r\n        \r\n        lines.append(f\"{i}. **{file_name}**\")\r\n        lines.append(f\"   ğŸ“… {timestamp} | ğŸ“± {app_used} {duration_str}\")\r\n        lines.append(f\"   ğŸ“‚ {entry['file_path']}\\n\")\r\n    \r\n    return \"\\n\".join(lines)\r\n\r\n\r\n# Auto-start tracking when module is imported\r\nstart_tracking()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Test the module\r\n    print(\"Testing file tracker...\")\r\n    print(\"Open some files to test tracking...\")\r\n    \r\n    # Keep main thread alive for testing\r\n    try:\r\n        while True:\r\n            time.sleep(1)\r\n    except KeyboardInterrupt:\r\n        stop_tracking()",
    "timestamp": "2026-02-04 01:38:17",
    "length": 13623
  },
  {
    "text": "\"\"\"\r\nFile Tracker Module for Pikachu Desktop Assistant\r\nTracks all file opens/access in real-time and logs activity\r\n\"\"\"\r\n\r\nimport os\r\nimport json\r\nimport time\r\nimport threading\r\nfrom datetime import datetime, timedelta\r\nfrom collections import defaultdict\r\nimport win32gui\r\nimport win32process\r\nimport psutil\r\n\r\n# Configuration\r\nFILE_ACTIVITY_LOG = \"file_activity_log.json\"\r\nMAX_LOG_DAYS = 30  # Keep last 30 days of activity\r\nCHECK_INTERVAL = 2  # Check every 2 seconds\r\n\r\n# Global state\r\nfile_activity_log = []\r\ntracking_active = False\r\ntracker_thread = None\r\ncurrently_open_files = {}  # Track files currently being accessed\r\n\r\n# System/temp paths to ignore\r\nIGNORE_PATHS = [\r\n    \"\\\\AppData\\\\Local\\\\Temp\",\r\n    \"\\\\Windows\\\\\",\r\n    \"\\\\System32\\\\\",\r\n    \"\\\\Program Files\\\\\",\r\n    \"\\\\ProgramData\\\\\",\r\n    \"\\\\$Recycle.Bin\",\r\n    \"\\\\.git\",\r\n    \"\\\\node_modules\",\r\n    \"\\\\venv\\\\\",\r\n    \"\\\\__pycache__\",\r\n]\r\n\r\n# File extensions we care about\r\nTRACKED_EXTENSIONS = [\r\n    # Documents\r\n    '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt',\r\n    # Spreadsheets\r\n    '.xlsx', '.xls', '.csv', '.ods',\r\n    # Presentations\r\n    '.pptx', '.ppt', '.odp',\r\n    # Images\r\n    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp',\r\n    # Videos\r\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv',\r\n    # Audio\r\n    '.mp3', '.wav', '.flac', '.aac', '.ogg',\r\n    # Code\r\n    '.py', '.js', '.java', '.cpp', '.c', '.html', '.css', '.json', '.xml',\r\n    # Archives\r\n    '.zip', '.rar', '.7z', '.tar', '.gz',\r\n    # Others\r\n    '.exe', '.msi', '.apk', '.dmg'\r\n]\r\n\r\n\r\ndef load_activity_log():\r\n    \"\"\"Load existing activity log from file\"\"\"\r\n    global file_activity_log\r\n    \r\n    if os.path.exists(FILE_ACTIVITY_LOG):\r\n        try:\r\n            with open(FILE_ACTIVITY_LOG, 'r', encoding='utf-8') as f:\r\n                file_activity_log = json.load(f)\r\n                print(f\"ğŸ“ Loaded {len(file_activity_log)} file activity records\")\r\n        except Exception as e:\r\n            print(f\"Error loading file activity log: {e}\")\r\n            file_activity_log = []\r\n    else:\r\n        file_activity_log = []\r\n\r\n\r\ndef save_activity_log():\r\n    \"\"\"Save activity log to file\"\"\"\r\n    try:\r\n        with open(FILE_ACTIVITY_LOG, 'w', encoding='utf-8') as f:\r\n            json.dump(file_activity_log, f, indent=2, ensure_ascii=False)\r\n    except Exception as e:\r\n        print(f\"Error saving file activity log: {e}\")\r\n\r\n\r\ndef should_ignore_file(file_path):\r\n    \"\"\"Check if file should be ignored based on path or extension\"\"\"\r\n    if not file_path:\r\n        return True\r\n    \r\n    # Ignore system/temp paths\r\n    for ignore_path in IGNORE_PATHS:\r\n        if ignore_path.lower() in file_path.lower():\r\n            return True\r\n    \r\n    # Check if extension is tracked\r\n    _, ext = os.path.splitext(file_path)\r\n    if ext.lower() not in TRACKED_EXTENSIONS:\r\n        return True\r\n    \r\n    return False\r\n\r\n\r\ndef get_active_window_file():\r\n    \"\"\"Get file path from currently active window\"\"\"\r\n    try:\r\n        # Get active window handle\r\n        hwnd = win32gui.GetForegroundWindow()\r\n        if not hwnd:\r\n            return None, None\r\n        \r\n        # Get window title\r\n        window_title = win32gui.GetWindowText(hwnd)\r\n        if not window_title:\r\n            return None, None\r\n        \r\n        # Get process ID\r\n        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n        \r\n        # Get process info\r\n        try:\r\n            process = psutil.Process(pid)\r\n            app_name = process.name()\r\n            \r\n            # Try to extract file path from window title\r\n            # Common patterns: \"filename.ext - AppName\", \"AppName - filename.ext\"\r\n            file_path = None\r\n            \r\n            # For many apps, the window title contains the file path or name\r\n            # Try to find a file path in the title\r\n            potential_paths = []\r\n            \r\n            # Check if title contains a full path\r\n            if ':\\\\' in window_title or window_title.startswith('/'):\r\n                # Extract path-like strings\r\n                parts = window_title.split(' - ')\r\n                for part in parts:\r\n                    part = part.strip()\r\n                    if ':\\\\' in part or part.startswith('/'):\r\n                        if os.path.exists(part):\r\n                            potential_paths.append(part)\r\n            \r\n            # Check process's open files\r\n            try:\r\n                open_files = process.open_files()\r\n                for f in open_files:\r\n                    if not should_ignore_file(f.path):\r\n                        # Check if filename appears in window title\r\n                        filename = os.path.basename(f.path)\r\n                        if filename in window_title:\r\n                            potential_paths.append(f.path)\r\n            except (psutil.AccessDenied, psutil.NoSuchProcess):\r\n                pass\r\n            \r\n            # Return the first valid path found\r\n            if potential_paths:\r\n                file_path = potential_paths[0]\r\n            \r\n            if file_path and not should_ignore_file(file_path):\r\n                return file_path, app_name\r\n                \r\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n            pass\r\n    \r\n    except Exception as e:\r\n        # Silently handle errors\r\n        pass\r\n    \r\n    return None, None\r\n\r\n\r\ndef log_file_activity(file_path, app_name, duration=None):\r\n    \"\"\"Log file access activity\"\"\"\r\n    global file_activity_log\r\n    \r\n    if should_ignore_file(file_path):\r\n        return\r\n    \r\n    # Create log entry\r\n    entry = {\r\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\r\n        'file_path': file_path,\r\n        'file_name': os.path.basename(file_path),\r\n        'file_type': os.path.splitext(file_path)[1].lower().replace('.', ''),\r\n        'app_used': app_name,\r\n        'duration_seconds': duration if duration else 0\r\n    }\r\n    \r\n    # Check if this is a duplicate of the most recent entry\r\n    if file_activity_log:\r\n        last_entry = file_activity_log[-1]\r\n        # If same file accessed within 5 minutes, update duration instead of adding new entry\r\n        if (last_entry['file_path'] == file_path and \r\n            last_entry['app_used'] == app_name):\r\n            last_time = datetime.strptime(last_entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            current_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n            time_diff = (current_time - last_time).total_seconds()\r\n            if time_diff < 300:  # 5 minutes\r\n                # Update existing entry's duration\r\n                last_entry['duration_seconds'] = int(time_diff)\r\n                save_activity_log()\r\n                return\r\n    \r\n    # Add new entry\r\n    file_activity_log.append(entry)\r\n    \r\n    # FIXED: Save immediately after adding new entry\r\n    save_activity_log()\r\n    \r\n    print(f\"ğŸ“ Tracked: {entry['file_name']} ({app_name})\")\r\n\r\n\r\ndef track_files():\r\n    \"\"\"Background thread that tracks file activity\"\"\"\r\n    global tracking_active, currently_open_files\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking started...\")\r\n    \r\n    while tracking_active:\r\n        try:\r\n            # Get currently active file\r\n            file_path, app_name = get_active_window_file()\r\n            \r\n            if file_path and app_name:\r\n                current_time = time.time()\r\n                \r\n                # Track when file was opened\r\n                file_key = f\"{file_path}|{app_name}\"\r\n                \r\n                if file_key not in currently_open_files:\r\n                    # New file opened\r\n                    currently_open_files[file_key] = {\r\n                        'path': file_path,\r\n                        'app': app_name,\r\n                        'start_time': current_time\r\n                    }\r\n                    log_file_activity(file_path, app_name)\r\n                else:\r\n                    # File still open, calculate duration\r\n                    duration = int(current_time - currently_open_files[file_key]['start_time'])\r\n                    if duration > 0 and duration % 60 == 0:  # Log every minute\r\n                        log_file_activity(file_path, app_name, duration)\r\n            \r\n            # Clean up closed files\r\n            closed_files = []\r\n            for file_key, info in currently_open_files.items():\r\n                current_time = time.time()\r\n                if current_time - info['start_time'] > CHECK_INTERVAL * 2:\r\n                    # File likely closed if not detected in 2 cycles\r\n                    closed_files.append(file_key)\r\n            \r\n            for file_key in closed_files:\r\n                del currently_open_files[file_key]\r\n            \r\n            # Check every N seconds\r\n            time.sleep(CHECK_INTERVAL)\r\n            \r\n        except Exception as e:\r\n            # Silently handle errors\r\n            print(f\"File tracking error: {e}\")\r\n            time.sleep(CHECK_INTERVAL)\r\n    \r\n    print(\"ğŸ‘ï¸ File tracking stopped.\")\r\n\r\n\r\ndef start_tracking():\r\n    \"\"\"Start the file tracking thread\"\"\"\r\n    global tracking_active, tracker_thread\r\n    \r\n    if tracking_active:\r\n        print(\"âš ï¸ File tracking already active\")\r\n        return\r\n    \r\n    # Load existing log\r\n    load_activity_log()\r\n    \r\n    # Cleanup old logs\r\n    cleanup_old_logs(MAX_LOG_DAYS)\r\n    \r\n    # Start tracking\r\n    tracking_active = True\r\n    tracker_thread = threading.Thread(target=track_files, daemon=True)\r\n    tracker_thread.start()\r\n    \r\n    print(\"âœ… File tracking activated\")\r\n\r\n\r\ndef stop_tracking():\r\n    \"\"\"Stop the file tracking thread\"\"\"\r\n    global tracking_active\r\n    \r\n    tracking_active = False\r\n    save_activity_log()\r\n    print(\"ğŸ›‘ File tracking deactivated\")\r\n\r\n\r\ndef get_recent_files(hours=24, file_type=None):\r\n    \"\"\"Get files accessed in the last N hours, optionally filtered by type\"\"\"\r\n    cutoff_time = datetime.now() - timedelta(hours=hours)\r\n    recent_files = []\r\n    \r\n    for entry in reversed(file_activity_log):  # Start from most recent\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if entry_time < cutoff_time:\r\n            break  # Stop if we've gone past the time range\r\n        \r\n        # Filter by file type if specified\r\n        if file_type and entry['file_type'] != file_type.lower():\r\n            continue\r\n        \r\n        recent_files.append(entry)\r\n    \r\n    return recent_files\r\n\r\n\r\ndef get_files_by_timerange(start_time, end_time):\r\n    \"\"\"Get files accessed within a specific time range\"\"\"\r\n    files_in_range = []\r\n    \r\n    for entry in file_activity_log:\r\n        entry_time = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\r\n        \r\n        if start_time <= entry_time <= end_time:\r\n            files_in_range.append(entry)\r\n    \r\n    return files_in_range\r\n\r\n\r\ndef cleanup_old_logs(days=30):\r\n    \"\"\"Remove log entries older than N days\"\"\"\r\n    global file_activity_log\r\n    \r\n    cutoff_date = datetime.now() - timedelta(days=days)\r\n    original_count = len(file_activity_log)\r\n    \r\n    file_activity_log = [\r\n        entry for entry in file_activity_log\r\n        if datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S') > cutoff_date\r\n    ]\r\n    \r\n    removed_count = original_count - len(file_activity_log)\r\n    \r\n    if removed_count > 0:\r\n        print(f\"ğŸ—‘ï¸ Cleaned up {removed_count} old file activity records\")\r\n        save_activity_log()\r\n\r\n\r\ndef format_file_activity_text(entries, limit=20):\r\n    \"\"\"Format file activity as readable text for display\"\"\"\r\n    if not entries:\r\n        return \"ğŸ“ **FILE ACTIVITY**\\n\\nâŒ No file activity found.\"\r\n    \r\n    entries = entries[:limit]  # Limit results\r\n    lines = [f\"ğŸ“ **FILE ACTIVITY** (Last {len(entries)} files)\\n\"]\r\n    \r\n    for i, entry in enumerate(entries, 1):\r\n        file_name = entry['file_name']\r\n        timestamp = entry['timestamp']\r\n        app_used = entry['app_used']\r\n        duration = entry.get('duration_seconds', 0)\r\n        \r\n        duration_str = f\"{duration}s\" if duration > 0 else \"\"\r\n        \r\n        lines.append(f\"{i}. **{file_name}**\")\r\n        lines.append(f\"   ğŸ“… {timestamp} | ğŸ“± {app_used} {duration_str}\")\r\n        lines.append(f\"   ğŸ“‚ {entry['file_path']}\\n\")\r\n    \r\n    return \"\\n\".join(lines)\r\n\r\n\r\n# Auto-start tracking when module is imported\r\nstart_tracking()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Test the module\r\n    print(\"Testing file tracker...\")\r\n    print(\"Open some files to test tracking...\")\r\n    \r\n    time.sleep(30)  # Track for 30 seconds\r\n    \r\n    print(\"\\n\" + \"=\"*80)\r\n    recent = get_recent_files(hours=1)\r\n    print(format_file_activity_text(recent, limit=10))\r\n    print(\"=\"*80)\r\n    \r\n    stop_tracking()",
    "timestamp": "2026-02-04 01:35:42",
    "length": 12728
  },
  {
    "text": "\"C:\\Users\\Suraj Kumar Sahoo\\clawd\\hahahaha.txt\"",
    "timestamp": "2026-02-04 01:34:09",
    "length": 47
  },
  {
    "text": "send me that PDF from today",
    "timestamp": "2026-02-04 01:19:10",
    "length": 27
  },
  {
    "text": "project_report",
    "timestamp": "2026-02-04 01:18:44",
    "length": 14
  },
  {
    "text": "> __:\r\nsend me that PDF from today\r\n",
    "timestamp": "2026-02-04 01:16:39",
    "length": 36
  },
  {
    "text": "YourName",
    "timestamp": "2026-02-04 01:13:01",
    "length": 8
  },
  {
    "text": "send me that PDF from yesterday afternoon",
    "timestamp": "2026-02-04 01:11:55",
    "length": 41
  },
  {
    "text": "{\r\n  \"timestamp\": \"2026-02-04 01:10:40\",\r\n  \"file_path\": \"C:/Users/YourName/Downloads/invoice.pdf\",\r\n  \"file_name\": \"invoice.pdf\",\r\n  \"file_type\": \"pdf\",\r\n  \"app_used\": \"Adobe Acrobat\",\r\n  \"duration_seconds\": 180\r\n}\r\n",
    "timestamp": "2026-02-04 01:11:21",
    "length": 217
  },
  {
    "text": "{\r\n  \"timestamp\": \"2026-02-03 23:41:12\",\r\n  \"file_path\": \"C:/Users/YourName/Downloads/invoice.pdf\",\r\n  \"file_name\": \"invoice.pdf\",\r\n  \"file_type\": \"pdf\",\r\n  \"app_used\": \"Adobe Acrobat\",\r\n  \"duration_seconds\": 180\r\n}\r\n",
    "timestamp": "2026-02-04 01:10:35",
    "length": 217
  },
  {
    "text": "{\r\n    \"timestamp\": \"2026-02-03 16:30:00\",\r\n    \"file_path\": \"C:/Users/YourName/Downloads/invoice.pdf\",\r\n    \"file_name\": \"invoice.pdf\",\r\n    \"file_type\": \"pdf\",\r\n    \"app_used\": \"Adobe Acrobat\",\r\n    \"duration_seconds\": 180\r\n  }",
    "timestamp": "2026-02-04 01:10:10",
    "length": 229
  },
  {
    "text": "2026-02-03 16:30:00\"",
    "timestamp": "2026-02-04 01:09:32",
    "length": 20
  },
  {
    "text": "type nul > \"%USERPROFILE%\\Downloads\\invoice.pdf\"\r\n",
    "timestamp": "2026-02-04 01:08:42",
    "length": 50
  },
  {
    "text": "Downloads",
    "timestamp": "2026-02-04 01:08:31",
    "length": 9
  },
  {
    "text": "type nul > \"C:\\Users\\YourName\\Downloads\\invoice.pdf\"\r\n",
    "timestamp": "2026-02-04 01:08:03",
    "length": 54
  },
  {
    "text": "\"timestamp\": \"2026-02-03 16:30:00\",\r\n    \"file_path\": \"C:/Users/YourName/Downloads/invoice.pdf\",",
    "timestamp": "2026-02-04 01:07:29",
    "length": 96
  },
  {
    "text": "\r\nğŸ“© Message from @surajj_ks: send me that PDF from yesterday afternoon\r\n2026-02-04 01:05:37,633 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/sendChatAction \"HTTP/1.1 200 OK\"\r\n2026-02-04 01:05:38,022 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/sendMessage \"HTTP/1.1 200 OK\"\r\nâš¡ Sending to Qwen: send me that PDF from yesterday afternoon\r\n2026-02-04 01:05:46,141 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/getUpdates \"HTTP/1.1 200 OK\"\r\n2026-02-04 01:05:56,339 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/getUpdates \"HTTP/1.1 200 OK\"\r\n2026-02-04 01:06:00,438 - httpx - INFO - HTTP Request: POST http://127.0.0.1:11434/api/chat \"HTTP/1.1 200 OK\"\r\n2026-02-04 01:06:01,407 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/deleteMessage \"HTTP/1.1 200 OK\"\r\n2026-02-04 01:06:01,817 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/sendMessage \"HTTP/1.1 200 OK\"\r\nğŸ” Searching for file...\r\n   Query: 'send me that PDF from yesterday afternoon'\r\n   âœ… Found: invoice.pdf (confidence: 75.0%)\r\n   âš ï¸ File was moved/deleted: C:/Users/YourName/Downloads/invoice.pdf\r\n2026-02-04 01:06:02,038 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/editMessageText \"HTTP/1.1 400 Bad Request\"\r\nFind file error: Message can't be edited\r\n2026-02-04 01:06:02,238 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/editMessageText \"HTTP/1.1 400 Bad Request\"\r\n2026-02-04 01:06:02,239 - telegram.ext.Application - ERROR - No error handlers are registered, logging exception.\r\nTraceback (most recent call last):\r\n  File \"C:\\pikachu-assistant\\tele_agent.py\", line 486, in handle_message\r\n    await search_msg.edit_text(message, reply_markup=get_main_keyboard())\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_message.py\", line 2537, in edit_text\r\n    return await self.get_bot().edit_message_text(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_extbot.py\", line 1480, in edit_message_text\r\n    return await super().edit_message_text(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 519, in decorator\r\n    result = await func(self, *args, **kwargs)  # skipcq: PYL-E1102\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 3282, in edit_message_text\r\n    return await self._send_message(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_extbot.py\", line 529, in _send_message\r\n    result = await super()._send_message(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 697, in _send_message\r\n    result = await self._post(\r\n             ^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 607, in _post\r\n    return await self._do_post(\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_extbot.py\", line 347, in _do_post\r\n    return await super()._do_post(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 635, in _do_post\r\n    return await request.post(\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\request\\_baserequest.py\", line 168, in post\r\n    result = await self._request_wrapper(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\request\\_baserequest.py\", line 325, in _request_wrapper\r\n    raise BadRequest(message)\r\ntelegram.error.BadRequest: Message can't be edited\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_application.py\", line 1195, in process_update\r\n    await coroutine\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_basehandler.py\", line 153, in handle_update\r\n    return await self.callback(update, context)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\tele_agent.py\", line 500, in handle_message\r\n    await search_msg.edit_text(f\"âŒ Search error: {e}\", reply_markup=get_main_keyboard())\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_message.py\", line 2537, in edit_text\r\n    return await self.get_bot().edit_message_text(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_extbot.py\", line 1480, in edit_message_text\r\n    return await super().edit_message_text(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 519, in decorator\r\n    result = await func(self, *args, **kwargs)  # skipcq: PYL-E1102\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 3282, in edit_message_text\r\n    return await self._send_message(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_extbot.py\", line 529, in _send_message\r\n    result = await super()._send_message(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 697, in _send_message\r\n    result = await self._post(\r\n             ^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 607, in _post\r\n    return await self._do_post(\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\ext\\_extbot.py\", line 347, in _do_post\r\n    return await super()._do_post(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\_bot.py\", line 635, in _do_post\r\n    return await request.post(\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\request\\_baserequest.py\", line 168, in post\r\n    result = await self._request_wrapper(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\pikachu-assistant\\venv\\Lib\\site-packages\\telegram\\request\\_baserequest.py\", line 325, in _request_wrapper\r\n    raise BadRequest(message)\r\ntelegram.error.BadRequest: Message can't be edited\r\n2026-02-04 01:06:06,537 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/getUpdates \"HTTP/1.1 200 OK\"\r\n2026-02-04 01:06:16,738 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot8465567232:AAHH0VeOoXT46_klnFC8Hx7D5e_jXNyG3LI/getUpdates \"HTTP/1.1 200 OK\"\r\n",
    "timestamp": "2026-02-04 01:06:23",
    "length": 7152
  },
  {
    "text": "send me that PDF from yesterday afternoon",
    "timestamp": "2026-02-04 01:03:15",
    "length": 41
  },
  {
    "text": "import os\r\nimport webbrowser\r\nimport pyautogui\r\nimport cv2\r\nimport screen_brightness_control as sbc\r\nimport psutil\r\nimport shutil\r\nimport sounddevice as sd\r\nfrom scipy.io.wavfile import write\r\nimport numpy as np\r\nimport requests\r\nimport json\r\nimport activity_monitor\r\nimport clipboard_monitor  # <--- NEW IMPORT ADDED\r\nfrom file_finder import find_files_from_query, format_search_results, get_file_path  # <--- FILE FINDER IMPORT\r\n\r\nPROCESS_NAMES = {\r\n    # Browsers\r\n    \"chrome\": \"chrome.exe\", \"googlechrome\": \"chrome.exe\", \"google\": \"chrome.exe\",\r\n    \"brave\": \"brave.exe\", \"bravebrowser\": \"brave.exe\", \r\n    \"edge\": \"msedge.exe\", \"msedge\": \"msedge.exe\", \"microsoftedge\": \"msedge.exe\",\r\n    \"firefox\": \"firefox.exe\", \"mozilla\": \"firefox.exe\",\r\n    \"opera\": \"opera.exe\",\r\n\r\n    # System & Tools\r\n    \"notepad\": \"notepad.exe\",\r\n    \"calculator\": \"calc.exe\", \"calc\": \"calc.exe\",\r\n    \"cmd\": \"cmd.exe\", \"terminal\": \"WindowsTerminal.exe\",\r\n    \"explorer\": \"explorer.exe\", \"fileexplorer\": \"explorer.exe\",\r\n    \"taskmanager\": \"Taskmgr.exe\",\r\n\r\n    # Media\r\n    \"spotify\": \"spotify.exe\",\r\n    \"vlc\": \"vlc.exe\", \r\n\r\n    # Coding\r\n    \"vscode\": \"Code.exe\", \"code\": \"Code.exe\", \"visualstudiocode\": \"Code.exe\",\r\n    \"pycharm\": \"pycharm64.exe\",\r\n    \"androidstudio\": \"studio64.exe\",\r\n    \"intellij\": \"idea64.exe\",\r\n    \"python\": \"python.exe\",\r\n\r\n    # Social\r\n    \"telegram\": \"Telegram.exe\",\r\n    \"discord\": \"Discord.exe\",\r\n    \"whatsapp\": \"WhatsApp.exe\",\r\n    \"zoom\": \"Zoom.exe\"\r\n}\r\n\r\ndef get_laptop_location():\r\n    \"\"\"\r\n    Gets the approximate location of the laptop using multiple IP geolocation services\r\n    for better accuracy. Tries 3 different APIs and returns the best result.\r\n    \"\"\"\r\n    try:\r\n        print(\"ğŸ” Fetching location from multiple sources...\")\r\n        \r\n        results = []\r\n        \r\n        try:\r\n            print(\"   â†’ Checking ipapi.co...\")\r\n            response = requests.get('https://ipapi.co/json/', timeout=5)\r\n            if response.status_code == 200:\r\n                data = response.json()\r\n                results.append({\r\n                    'source': 'ipapi.co',\r\n                    'ip': data.get('ip', 'Unknown'),\r\n                    'city': data.get('city', 'Unknown'),\r\n                    'region': data.get('region', 'Unknown'),\r\n                    'country': data.get('country_name', 'Unknown'),\r\n                    'country_code': data.get('country_code', 'Unknown'),\r\n                    'postal': data.get('postal', 'Unknown'),\r\n                    'latitude': data.get('latitude', 0),\r\n                    'longitude': data.get('longitude', 0),\r\n                    'timezone': data.get('timezone', 'Unknown'),\r\n                    'org': data.get('org', 'Unknown'),\r\n                })\r\n                print(f\"      âœ“ Found: {data.get('city', 'Unknown')}\")\r\n        except Exception as e:\r\n            print(f\"      âœ— ipapi.co failed: {e}\")\r\n        \r\n        try:\r\n            print(\"   â†’ Checking ip-api.com...\")\r\n            response = requests.get('http://ip-api.com/json/?fields=status,message,country,countryCode,region,regionName,city,zip,lat,lon,timezone,isp,org,as,query', timeout=5)\r\n            if response.status_code == 200:\r\n                data = response.json()\r\n                if data.get('status') == 'success':\r\n                    results.append({\r\n                        'source': 'ip-api.com',\r\n                        'ip': data.get('query', 'Unknown'),\r\n                        'city': data.get('city', 'Unknown'),\r\n                        'region': data.get('regionName', 'Unknown'),\r\n                        'country': data.get('country', 'Unknown'),\r\n                        'country_code': data.get('countryCode', 'Unknown'),\r\n                        'postal': data.get('zip', 'Unknown'),\r\n                        'latitude': data.get('lat', 0),\r\n                        'longitude': data.get('lon', 0),\r\n                        'timezone': data.get('timezone', 'Unknown'),\r\n                        'org': data.get('isp', 'Unknown'),\r\n                    })\r\n                    print(f\"      âœ“ Found: {data.get('city', 'Unknown')}\")\r\n        except Exception as e:\r\n            print(f\"      âœ— ip-api.com failed: {e}\")\r\n        \r\n        try:\r\n            print(\"   â†’ Checking ipinfo.io...\")\r\n            response = requests.get('https://ipinfo.io/json', timeout=5)\r\n            if response.status_code == 200:\r\n                data = response.json()\r\n                loc = data.get('loc', '0,0').split(',')\r\n                results.append({\r\n                    'source': 'ipinfo.io',\r\n                    'ip': data.get('ip', 'Unknown'),\r\n                    'city': data.get('city', 'Unknown'),\r\n                    'region': data.get('region', 'Unknown'),\r\n                    'country': data.get('country', 'Unknown'),\r\n                    'country_code': data.get('country', 'Unknown'),\r\n                    'postal': data.get('postal', 'Unknown'),\r\n                    'latitude': float(loc[0]) if len(loc) > 0 else 0,\r\n                    'longitude': float(loc[1]) if len(loc) > 1 else 0,\r\n                    'timezone': data.get('timezone', 'Unknown'),\r\n                    'org': data.get('org', 'Unknown'),\r\n                })\r\n                print(f\"      âœ“ Found: {data.get('city', 'Unknown')}\")\r\n        except Exception as e:\r\n            print(f\"      âœ— ipinfo.io failed: {e}\")\r\n        \r\n        if not results:\r\n            print(\"âŒ All location APIs failed\")\r\n            return None\r\n        \r\n        best_result = None\r\n        for result in results:\r\n            if result['source'] == 'ip-api.com':  \r\n                best_result = result\r\n                break\r\n        \r\n        if not best_result:\r\n            best_result = results[0] \r\n        \r\n       \r\n        if len(results) > 1:\r\n            comparison = \"\\n\".join([f\"   â€¢ {r['source']}: {r['city']}, {r['region']}\" for r in results])\r\n            best_result['comparison'] = comparison\r\n        else:\r\n            best_result['comparison'] = None\r\n        \r\n       \r\n        lat = best_result['latitude']\r\n        lon = best_result['longitude']\r\n        best_result['maps_url'] = f\"https://www.google.com/maps?q={lat},{lon}\"\r\n        \r\n        print(f\"âœ… Best location: {best_result['city']}, {best_result['region']} (from {best_result['source']})\")\r\n        return best_result\r\n            \r\n    except Exception as e:\r\n        print(f\"âŒ Error getting location: {e}\")\r\n        return None\r\n\r\n\r\ndef get_browser_path(browser_name):\r\n    \"\"\"Finds browser executable dynamically without hardcoded paths.\"\"\"\r\n    browser_name = browser_name.lower().strip()\r\n    \r\n    exes = {\r\n        \"chrome\": \"chrome.exe\",\r\n        \"google\": \"chrome.exe\",\r\n        \"brave\": \"brave.exe\", \r\n        \"firefox\": \"firefox.exe\",\r\n        \"mozilla\": \"firefox.exe\",\r\n        \"edge\": \"msedge.exe\",\r\n        \"msedge\": \"msedge.exe\",\r\n        \"opera\": \"launcher.exe\" \r\n    }\r\n    \r\n    executable = exes.get(browser_name, f\"{browser_name}.exe\")\r\n    if not executable.endswith(\".exe\"): executable += \".exe\"\r\n    \r\n   \r\n    path = shutil.which(executable)\r\n    if path: return path\r\n    \r\n    \r\n    possible_roots = [\r\n        os.environ.get(\"PROGRAMFILES\"), \r\n        os.environ.get(\"PROGRAMFILES(X86)\"),\r\n        os.environ.get(\"LOCALAPPDATA\") \r\n    ]\r\n    \r\n    common_subdirs = [\r\n        \"Google\\\\Chrome\\\\Application\",\r\n        \"BraveSoftware\\\\Brave-Browser\\\\Application\",\r\n        \"Microsoft\\\\Edge\\\\Application\",\r\n        \"Mozilla Firefox\",\r\n        \"Opera\"\r\n    ]\r\n    \r\n    for root in possible_roots:\r\n        if not root: continue\r\n        for subdir in common_subdirs:\r\n            full_path = os.path.join(root, subdir, executable)\r\n            if os.path.exists(full_path):\r\n                return full_path\r\n                \r\n    return None\r\n\r\n\r\ndef capture_webcam():\r\n    print(\"ğŸ“¸ Accessing Webcam...\")\r\n    try:\r\n       \r\n        for i in range(2):\r\n            cam = cv2.VideoCapture(i)\r\n            if cam.isOpened():\r\n                ret, frame = cam.read()\r\n                if ret:\r\n                    file_path = os.path.join(os.getcwd(), \"webcam_snap.jpg\")\r\n                    cv2.imwrite(file_path, frame)\r\n                    cam.release()\r\n                    return file_path\r\n                cam.release()\r\n        print(\"âŒ No active camera found.\")\r\n        return None\r\n    except Exception as e:\r\n        print(f\"Error accessing webcam: {e}\")\r\n        return None\r\n\r\n\r\ndef capture_screen():\r\n    file_path = os.path.join(os.getcwd(), \"screenshot.png\")\r\n    try:\r\n        print(\"ğŸ“¸ Taking screenshot...\")\r\n        screenshot = pyautogui.screenshot()\r\n        screenshot.save(file_path)\r\n        return file_path\r\n    except Exception as e:\r\n        print(f\"Error taking screenshot: {e}\")\r\n        return None\r\n\r\n\r\ndef record_audio(duration=10):\r\n    \"\"\"Records audio from the default microphone for specified duration (in seconds).\r\n    Uses sounddevice library - Works on Windows Python 3.10 without C++ compiler!\"\"\"\r\n    file_path = os.path.join(os.getcwd(), \"audio_recording.wav\")\r\n    \r\n    # Audio recording parameters\r\n    SAMPLE_RATE = 44100 \r\n    CHANNELS = 1 \r\n    \r\n    print(f\"ğŸ¤ Recording audio for {duration} seconds...\")\r\n    \r\n    try:\r\n     \r\n        recording = sd.rec(\r\n            int(duration * SAMPLE_RATE), \r\n            samplerate=SAMPLE_RATE, \r\n            channels=CHANNELS, \r\n            dtype='int16'\r\n        )\r\n      \r\n        sd.wait()\r\n        \r\n        print(\"âœ… Recording complete.\")\r\n        \r\n       \r\n        write(file_path, SAMPLE_RATE, recording)\r\n        \r\n        return file_path\r\n        \r\n    except Exception as e:\r\n        print(f\"âŒ Error recording audio: {e}\")\r\n        return None\r\n\r\n\r\ndef system_sleep():\r\n    print(\"ğŸ’¤ Going to sleep...\")\r\n    os.system(\"rundll32.exe powrprof.dll,SetSuspendState 0,1,0\")\r\n\r\n\r\ndef get_battery_status():\r\n    try:\r\n        battery = psutil.sensors_battery()\r\n        if not battery:\r\n            return \"Cannot determine battery status (Device might be a Desktop).\"\r\n        \r\n        percent = battery.percent\r\n        charging = battery.power_plugged\r\n        status = \"Charging âš¡\" if charging else \"Discharging ğŸ”‹\"\r\n        \r\n        return f\"Battery is at {percent}% and is currently {status}.\"\r\n    except Exception as e:\r\n        return f\"Error reading battery: {e}\"\r\n\r\n\r\ndef get_system_health():\r\n    try:\r\n        cpu_usage = psutil.cpu_percent(interval=1)\r\n        ram = psutil.virtual_memory()\r\n        ram_usage = ram.percent\r\n        ram_available = round(ram.available / (1024 * 1024 * 1024), 2)\r\n        return f\"ğŸ–¥ï¸ **System Health:**\\nCPU Usage: {cpu_usage}%\\nRAM Usage: {ram_usage}% ({ram_available} GB free)\"\r\n    except Exception as e:\r\n        return f\"Error reading system health: {e}\"\r\n\r\n\r\ndef clear_recycle_bin():\r\n    \"\"\"\r\n    Clears the Windows Recycle Bin permanently.\r\n    Uses PowerShell command to empty all recycle bins on all drives.\r\n    \"\"\"\r\n    print(\"ğŸ—‘ï¸ Clearing Recycle Bin...\")\r\n    \r\n    try:\r\n        # PowerShell command to clear recycle bin for all drives\r\n        ps_command = 'Clear-RecycleBin -Force -ErrorAction SilentlyContinue'\r\n        \r\n        # Execute PowerShell command\r\n        result = os.system(f'powershell -Command \"{ps_command}\"')\r\n        \r\n        if result == 0:\r\n            print(\"âœ… Recycle Bin cleared successfully!\")\r\n            return \"Recycle Bin has been emptied successfully. All deleted files have been permanently removed.\"\r\n        else:\r\n            print(\"âš ï¸ Recycle Bin might be already empty or operation completed with warnings.\")\r\n            return \"Recycle Bin operation completed. It may have been already empty.\"\r\n            \r\n    except Exception as e:\r\n        error_msg = f\"Error clearing recycle bin: {e}\"\r\n        print(f\"âŒ {error_msg}\")\r\n        return error_msg\r\n\r\n\r\ndef check_storage():\r\n    \"\"\"\r\n    Checks storage space for all available drives on the system.\r\n    Returns detailed information about each drive including total, used, and free space.\r\n    \"\"\"\r\n    print(\"ğŸ’¾ Checking storage for all drives...\")\r\n    \r\n    try:\r\n        storage_info = []\r\n        partitions = psutil.disk_partitions()\r\n        \r\n        for partition in partitions:\r\n            # Skip CD/DVD drives and other removable media\r\n            if 'cdrom' in partition.opts or partition.fstype == '':\r\n                continue\r\n                \r\n            try:\r\n                usage = psutil.disk_usage(partition.mountpoint)\r\n                \r\n                # Convert bytes to GB\r\n                total_gb = round(usage.total / (1024 ** 3), 2)\r\n                used_gb = round(usage.used / (1024 ** 3), 2)\r\n                free_gb = round(usage.free / (1024 ** 3), 2)\r\n                percent_used = usage.percent\r\n                \r\n                # Determine status emoji based on usage\r\n                if percent_used >= 90:\r\n                    status_emoji = \"ğŸ”´\"  # Critical\r\n                elif percent_used >= 75:\r\n                    status_emoji = \"ğŸŸ¡\"  # Warning\r\n                else:\r\n                    status_emoji = \"ğŸŸ¢\"  # Good\r\n                \r\n                # FIX: Remove backslashes to prevent Markdown parsing errors\r\n                # invalid: **C:\\** (escapes the closing stars)\r\n                # valid: **C:**\r\n                safe_drive_name = partition.mountpoint.replace('\\\\', '')\r\n                \r\n                drive_info = {\r\n                    'drive': safe_drive_name,\r\n                    'filesystem': partition.fstype,\r\n                    'total': total_gb,\r\n                    'used': used_gb,\r\n                    'free': free_gb,\r\n                    'percent': percent_used,\r\n                    'status': status_emoji\r\n                }\r\n                \r\n                storage_info.append(drive_info)\r\n                \r\n                print(f\"   {status_emoji} {partition.mountpoint} - {percent_used}% used ({free_gb} GB free)\")\r\n                \r\n            except PermissionError:\r\n                # Skip drives that we don't have permission to access\r\n                continue\r\n            except Exception as e:\r\n                print(f\"   âš ï¸ Could not read {partition.mountpoint}: {e}\")\r\n                continue\r\n        \r\n        if not storage_info:\r\n            return \"No readable drives found.\"\r\n        \r\n        # Format the response\r\n        response_lines = [\"ğŸ’¾ **Storage Status:**\\n\"]\r\n        \r\n        for drive in storage_info:\r\n            response_lines.append(\r\n                f\"{drive['status']} **{drive['drive']}** ({drive['filesystem']})\\n\"\r\n                f\"   Total: {drive['total']} GB\\n\"\r\n                f\"   Used: {drive['used']} GB ({drive['percent']}%)\\n\"\r\n                f\"   Free: {drive['free']} GB\\n\"\r\n            )\r\n        \r\n        # Add summary\r\n        total_storage = sum(d['total'] for d in storage_info)\r\n        total_used = sum(d['used'] for d in storage_info)\r\n        total_free = sum(d['free'] for d in storage_info)\r\n        avg_percent = round(sum(d['percent'] for d in storage_info) / len(storage_info), 1)\r\n        \r\n        response_lines.append(\r\n            f\"\\nğŸ“Š **Overall Summary:**\\n\"\r\n            f\"   Total Storage: {round(total_storage, 2)} GB\\n\"\r\n            f\"   Used: {round(total_used, 2)} GB\\n\"\r\n            f\"   Free: {round(total_free, 2)} GB\\n\"\r\n            f\"   Average Usage: {avg_percent}%\"\r\n        )\r\n        \r\n        result = \"\\n\".join(response_lines)\r\n        print(\"âœ… Storage check complete!\")\r\n        return result\r\n        \r\n    except Exception as e:\r\n        error_msg = f\"Error checking storage: {e}\"\r\n        print(f\"âŒ {error_msg}\")\r\n        return error_msg\r\n\r\n\r\ndef open_browser(url, browser_name=\"default\"):\r\n    print(f\"ğŸŒ Request to open '{url}' in '{browser_name}'\")\r\n    \r\n    try:\r\n       \r\n        if not browser_name or browser_name.lower() == \"default\":\r\n            webbrowser.open(url)\r\n            return\r\n\r\n        \r\n        path = get_browser_path(browser_name)\r\n        \r\n        if path:\r\n            print(f\"   -> Found browser at: {path}\")\r\n            \r\n            webbrowser.register(browser_name, None, webbrowser.BackgroundBrowser(path))\r\n            webbrowser.get(browser_name).open(url)\r\n        else:\r\n            print(f\"âš ï¸ Could not find '{browser_name}'. Falling back to default.\")\r\n            webbrowser.open(url)\r\n            \r\n    except Exception as e:\r\n        print(f\"Error opening browser: {e}\")\r\n        webbrowser.open(url)\r\n\r\ndef close_application(app_name):\r\n   \r\n    clean_name = app_name.lower()\r\n    for word in [\"the \", \"app \", \"application \", \"close \", \"open \"]:\r\n        clean_name = clean_name.replace(word, \"\")\r\n    \r\n    \r\n    app_key = clean_name.strip().replace(\" \", \"\")\r\n    \r\n  \r\n    if app_key in PROCESS_NAMES:\r\n        exe_name = PROCESS_NAMES[app_key]\r\n    else:\r\n        exe_name = f\"{app_key}.exe\"\r\n        \r\n    print(f\"ğŸ’€ Killing process target: {exe_name}\")\r\n    \r\n    try:\r\n        os.system(f\"taskkill /f /im {exe_name} /t\")\r\n    except Exception as e:\r\n        print(f\"Error closing app: {e}\")\r\n\r\ndef open_file_path(path):\r\n    try:\r\n        if \"download\" in path.lower():\r\n            path = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\r\n        elif \"desktop\" in path.lower():\r\n            path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\r\n        elif \"c drive\" in path.lower() or \"c:\" in path.lower():\r\n            path = \"C:/\"\r\n            \r\n        if os.path.exists(path):\r\n            os.startfile(path)\r\n        else:\r\n            print(f\"âŒ Path not found: {path}\")\r\n    except Exception as e:\r\n        print(f\"Error opening path: {e}\")\r\n\r\ndef set_brightness(level):\r\n    try:\r\n        sbc.set_brightness(level)\r\n    except Exception as e:\r\n        print(f\"Error setting brightness: {e}\")\r\n\r\ndef execute_find_file(action_data):\r\n    \"\"\"\r\n    Execute file finding using the file_finder module\r\n    Returns file path if found (for Telegram sending), or error message\r\n    \"\"\"\r\n    print(\"ğŸ” Searching for file...\")\r\n    \r\n    try:\r\n        # Get the search query (brain.py now sends \"query\" instead of time_query/file_type)\r\n        query = action_data.get(\"query\")\r\n        \r\n        if not query:\r\n            # Fallback for old format (backward compatibility)\r\n            time_query = action_data.get(\"time_query\")\r\n            file_type = action_data.get(\"file_type\")\r\n            keyword = action_data.get(\"keyword\")\r\n            \r\n            if time_query:\r\n                query = time_query\r\n            else:\r\n                parts = []\r\n                if file_type:\r\n                    parts.append(file_type)\r\n                if keyword:\r\n                    parts.append(keyword)\r\n                query = \" \".join(parts) if parts else \"recent files\"\r\n        \r\n        # Search for files using the natural language query\r\n        print(f\"   Query: '{query}'\")\r\n        results = find_files_from_query(query, limit=3)\r\n        \r\n        if not results:\r\n            # No files found - return helpful message\r\n            print(\"   âŒ No matching files found\")\r\n            return {\r\n                \"status\": \"not_found\",\r\n                \"message\": \"âš ï¸ No matching files found.\\n\\nTry:\\nâ€¢ 'files opened today'\\nâ€¢ 'PDFs from yesterday'\\nâ€¢ 'recent documents'\"\r\n            }\r\n        \r\n        # Files found!\r\n        top_result = results[0]\r\n        file_path = top_result['file_path']\r\n        file_name = top_result['file_name']\r\n        confidence = top_result.get('confidence_score', 0)\r\n        \r\n        print(f\"   âœ… Found: {file_name} (confidence: {confidence}%)\")\r\n        \r\n        # Check if file still exists\r\n        if not os.path.exists(file_path):\r\n            print(f\"   âš ï¸ File was moved/deleted: {file_path}\")\r\n            \r\n            # If we have multiple results, try the next one\r\n            if len(results) > 1:\r\n                for result in results[1:]:\r\n                    if os.path.exists(result['file_path']):\r\n                        file_path = result['file_path']\r\n                        file_name = result['file_name']\r\n                        print(f\"   âœ… Using alternate: {file_name}\")\r\n                        break\r\n                else:\r\n                    # None of the results exist\r\n                    return {\r\n                        \"status\": \"file_deleted\",\r\n                        \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                    }\r\n            else:\r\n                return {\r\n                    \"status\": \"file_deleted\",\r\n                    \"message\": f\"âŒ File was found but no longer exists:\\n{file_name}\\n\\nIt may have been moved or deleted.\"\r\n                }\r\n        \r\n        # Check file size (Telegram limit is 50MB, warn if >20MB)\r\n        file_size_mb = os.path.getsize(file_path) / (1024 * 1024)\r\n        \r\n        if file_size_mb > 50:\r\n            return {\r\n                \"status\": \"too_large\",\r\n                \"message\": f\"âŒ File is too large to send via Telegram:\\n{file_name}\\n\\nSize: {file_size_mb:.1f} MB (Telegram limit: 50 MB)\\n\\nPath: {file_path}\"\r\n            }\r\n        \r\n        # Success - return file info for Telegram to send\r\n        return {\r\n            \"status\": \"found\",\r\n            \"file_path\": file_path,\r\n            \"file_name\": file_name,\r\n            \"file_size_mb\": file_size_mb,\r\n            \"confidence\": confidence,\r\n            \"results\": results  # All results for reference\r\n        }\r\n        \r\n    except Exception as e:\r\n        error_msg = f\"Error during file search: {e}\"\r\n        print(f\"   âŒ {error_msg}\")\r\n        return {\r\n            \"status\": \"error\",\r\n            \"message\": f\"âŒ Search error: {e}\"\r\n        }\r\n\r\ndef execute_command(cmd_json):\r\n    if not cmd_json: return\r\n    action = cmd_json.get(\"action\")\r\n    \r\n    if action == \"take_screenshot\": return capture_screen() \r\n    elif action == \"camera_stream\" or action == \"camera_snap\": return capture_webcam()\r\n    elif action == \"check_battery\": return get_battery_status()\r\n    elif action == \"check_health\": return get_system_health()\r\n    elif action == \"get_location\": return get_laptop_location() \r\n    elif action == \"system_sleep\": system_sleep()\r\n    elif action == \"record_audio\": \r\n        duration = cmd_json.get(\"duration\", 10)\r\n        return record_audio(duration)\r\n    elif action == \"clear_recycle_bin\": return clear_recycle_bin()\r\n    elif action == \"check_storage\": return check_storage()\r\n    \r\n    elif action == \"open_url\": \r\n        open_browser(cmd_json.get(\"url\"), cmd_json.get(\"browser\", \"default\"))\r\n        \r\n    elif action == \"close_app\": close_application(cmd_json.get(\"app_name\"))\r\n    elif action == \"open_app\":\r\n        app_name = cmd_json.get(\"app_name\")\r\n        print(f\"ğŸš€ Launching {app_name}...\")\r\n        pyautogui.press(\"win\")\r\n        pyautogui.sleep(0.1)\r\n        pyautogui.write(app_name)\r\n        pyautogui.sleep(0.5)\r\n        pyautogui.press(\"enter\")\r\n    elif action == \"system_control\":\r\n        feature = cmd_json.get(\"feature\")\r\n        val = cmd_json.get(\"value\")\r\n        if feature == \"brightness\": set_brightness(val)\r\n    elif action == \"open_file\": open_file_path(cmd_json.get(\"path\"))\r\n\r\n    elif action == \"get_activities\":\r\n        return activity_monitor.get_current_activities()\r\n\r\n    elif action == \"get_clipboard_history\":\r\n        return clipboard_monitor.get_clipboard_history()\r\n\r\n    elif action == \"find_file\":\r\n        return execute_find_file(cmd_json)",
    "timestamp": "2026-02-04 01:01:44",
    "length": 23444
  },
  {
    "text": "\r\n[1/5] Testing Module Imports...\r\n   âŒ brain.py import failed: No module named 'ollama'\r\nPS C:\\pikachu-assistant>\r\n",
    "timestamp": "2026-02-04 00:41:00",
    "length": 116
  },
  {
    "text": "C:/Users/Documents/test_document.pdf",
    "timestamp": "2026-02-03 23:45:24",
    "length": 36
  },
  {
    "text": "ollama==0.1.6\r\nscreen-brightness-control==0.16.1\r\npsutil==5.9.8\r\npython-dotenv\r\nopencv-python\r\npyautogui\r\npython-telegram-bot==20.6\r\nhttpx==0.25.2\r\nsounddevice==0.4.6\r\nscipy==1.11.4\r\nrequests==2.31.0\r\npywin32>=305\r\npyperclip\r\nSpeechRecognition\r\npyttsx3",
    "timestamp": "2026-02-03 23:00:59",
    "length": 252
  },
  {
    "text": "ModuleNotFoundError: No module named 'win32gui'\r\nPS C:\\pikachu-assistant> python test_file_tracker.py\r\nTraceback (most recent call last):\r\n  File \"C:\\pikachu-assistant\\test_file_tracker.py\", line 9, in <module>\r\n    import file_tracker\r\n  File \"C:\\pikachu-assistant\\file_tracker.py\", line 12, in <module>\r\n    import win32gui\r\nModuleNotFoundError: No module named 'win32gui'\r\nPS C:\\pikachu-assistant>",
    "timestamp": "2026-02-03 22:59:00",
    "length": 400
  },
  {
    "text": "python test_file_tracker.py\r\n",
    "timestamp": "2026-02-03 22:58:49",
    "length": 29
  }
]